import { Start as hA } from "./WebSharper.Core.JavaScript/Runtime.js"
import { Lazy as hB, MarkResizable as hC, SetOptional as hD, Force as hE, Create as hF, GetOptional as hG, CreateFuncWithArgs as hH, DeleteEmptyFields as hI, OnLoad as hJ } from "./WebSharper.Core.JavaScript/Runtime.js"
function a(hK){ return"Dispose"in hK;}
function b(){ const hK=bX.EmbedView(u0039((hS) => hS.$==1?q():C(), e().View));const hL=c(d(), {$:1});const hM=c(d(), {$:0});const hN=new n("New_1");const hO=(hN.h.push(new U("url_home", hM)),hN);const hP=(hO.h.push(new U("url_page1", hL)),hO);const hQ=(hP.h.push(new T("maincontainer", hK)),hP);const hR=bQ(hQ.k, hQ.h, []);hQ.i=new S(hR[1], dQ(hR[0]));}
function c(hK, hL){ return"#"+bY(hK, hL);}
function d(){ return u0038.router;}
function e(){ return u0038.currentPage;}
function f(hK, hL){ h(hK, hL);return hK[hL];}
function g(hK){ return hK.dims===2?hK.length*hK.length:hK.length;}
function h(hK, hL){ if(hL<0||hL>=hK.length)j("Index was outside the bounds of the array.");}
function i(hK, hL, hM){ h(hK, hL);hK[hL]=hM;}
function j(hK){ throw new Error(hK);}
function k(hK){ return[hK.K, hK.V];}
function l(hK, hL){ const hM=1+hL-hK;return hM<=0?[]:bI(hM, (hN) => hN+hK);}
let m=hB((hK) => class hL { static { m=hK(this);} Equals(hM){ return this===hM;} GetHashCode(){ return -1;} });
let n=hB((hK) => class hL extends m { static { n=hK(this);} i;k;h;s;static New_1(){ return new this("New_1");} constructor(hM){ if(hM=="New_1"){ let hN;super();this.i=null;this.k=(hN=u0036(),String(hN));this.h=hC([]);hD(this, "s", null);} } });
let o=hB((hK) => class hL extends m { static { o=hK(this);} ForTextView(){ console.warn("Content hole filled with attribute data", this.Name);return null;} AddAttribute(hM, hN){ console.warn("Var hole filled with non-Var data", this.Name);} get AsChoiceView(){ console.warn("Attribute value hole filled with non-text data", this.Name);return f4("");} });
let p=hB((hK) => class hL { static { p=hK(this);} });
function q(){ r();const hK=(h6) => h6.LastPrice*h6.Amount;const hL=u0039((h6) => bl(hK, h6), s().v);const hM=(h6) => h6.LastPrice*h6.Amount-h6.Price*h6.Amount;const hN=u0039((h6) => bl(hM, h6), s().v);const hO=u0039((h6) => h6>=0?"rgb(0, 255, 0)":"red", hN);const hP=$((h6, h7) =>(h7*100/h6).toFixed(2), hL, hN);const hQ=u0039((h6) => h6.toFixed(2)+"$", hN);const hR=u0039((h6) => h6.toFixed(2)+"$", hL);const hS=bX.Convert((h6) => { const h7=h6.Amount*h6.Price;const h8=h6.LastPrice*h6.Amount;const h9=[h7, h8, h8-h7, (it) => it.toFixed(2)];const h_=h9[2];const h$=h9[3];const ia=h$(h9[1]);const ib=h$(h9[0]);const ic=h$(h_);const id=h$(h6.LastPrice);const ie=h$(h6.Price);const if_1=h$(h6.Amount);const ig=new n("New_1");const ih=(ig.h.push(new U("stockname", h6.Name)),ig);const ii=(ih.h.push(new U("stockamount", if_1)),ih);const ij=(ii.h.push(new U("stockprice", ie)),ii);const ik=(ij.h.push(new U("stocklast", id)),ij);const il=(ik.h.push(new U("color", h_>=0?"rgb(0, 255, 0)":"red")),ik);const im=(il.h.push(new U("stockprofitandloss", ic)),il);const in_1=(im.h.push(new U("stockcostbasis", ib)),im);const io=(in_1.h.push(new U("stockmarketvalue", ia)),in_1);const ip=(io.h.push(bP(io.k, "remove", () => io.i, () => { s().RemoveByKey(h6.Name);})),io);const iq=bQ(ip.k, ip.h, []);const ir=new S(iq[1], bR(iq[0]));let is=(ip.i=ir,ir);return is.Doc;}, s().v);const hT=new n("New_1");const hU=(hT.h.push(new T("stocktablebody", hS)),hT);const hV=(hU.h.push(new cK("stockname", v())),hU);const hW=(hV.h.push(new cJ("stockamount", u())),hV);const hX=(hW.h.push(new cJ("stockprice", t())),hW);const hY=(hX.h.push(new cI("assetamount", hR)),hX);const hZ=(hY.h.push(new cI("assetprofitandloss", hQ)),hY);const h0=(hZ.h.push(new cI("assetprofitandlosspercent", hP)),hZ);const h1=(h0.h.push(new cI("colorprofitandloss", hO)),h0);const h2=(h1.h.push(bP(h1.k, "add", () => h1.i, () => { const h6=v();const h7=u();const h8=t();if(!cM(h6.Get())&&h7.Get()>0&&h8.Get()>0){ const h9=bO(h6.Get(), h7.Get(), h8.Get(), w(h8.Get()));s().Append(h9);h6.Set("");h7.Set(0);h8.Set(0);} })),h1);const h3=bQ(h2.k, h2.h, [["stockname", 0, null], ["stockamount", 1, null], ["stockprice", 1, null]]);const h4=new S(h3[1], bS(h3[0]));let h5=(h2.i=h4,h4);return h5.Doc;}
function r(){ const hK=null;ei(ed(() => ee(() => true, ed(() => ef(eg(3000), () => { z();return eh();})))), null);}
function s(){ return u0038.stockModel;}
function t(){ return u0038.stockP;}
function u(){ return u0038.stockA;}
function v(){ return u0038.stockN;}
function w(hK){ return hK*(1+((A(),Math.random())-0.5)*0.2);}
function x(hK){ const hL=JSON.stringify(((es(et()))())(hK));globalThis.localStorage.setItem("stocks", hL);}
function y(){ const hK=globalThis.localStorage.getItem("");if(hK==null)return B();else try { return b9((hL) => bO(hL.Name, hL.Amount, hL.Price, w(hL.Price)), ((eu(et()))())(JSON.parse(hK)));} catch(hL){ return B();} }
function z(){ s().Iter((hK) => { const hL=w(hK.Price);s().UpdateBy((hM) => hM.Name==hK.Name?bV(bO(hM.Name, hM.Amount, hM.Price, hL)):null, hK.Name);});}
function A(){ return u0038.random;}
function B(){ return u0038.initialStockData;}
function C(){ const hK=new n("New_1");const hL=(hK.h.push(new cK("incomegroup", J())),hK);const hM=(hL.h.push(new cJ("gains", I())),hL);const hN=(hM.h.push(new cK("expensegroup", H())),hM);const hO=(hN.h.push(new cJ("losses", G())),hN);const hP=(hO.h.push(new cI("income", F())),hO);const hQ=(hP.h.push(new cI("expenses", E())),hP);const hR=(hQ.h.push(new cI("balance", D())),hQ);const hS=(hR.h.push(bP(hR.k, "gainings", () => hR.i, () => { if(!cM(J().Get())&&I().Get()!==0)K();})),hR);const hT=(hS.h.push(bP(hS.k, "losings", () => hS.i, () => { if(!cM(H().Get())&&G().Get()!==0)L();})),hS);const hU=bQ(hT.k, hT.h, [["incomegroup", 0, null], ["gains", 1, null], ["expensegroup", 0, null], ["losses", 1, null]]);const hV=new S(hU[1], bT(hU[0]));let hW=(hT.i=hV,hV);return hW.Doc;}
function D(){ return u0038.balanceView;}
function E(){ return u0038.totalExpensesView;}
function F(){ return u0038.totalIncomeView;}
function G(){ return u0038.loss;}
function H(){ return u0038.expensegroup;}
function I(){ return u0038.gain;}
function J(){ return u0038.incomegroup;}
function K(){ const hK=N().Get();const hL=J().Get();const hM=I().Get();const hN=O().Get();const hO=P(hK, hL, hM, hN[0], hN[1]);O().Set([hO[0], hO[1]]);N().Set(hO[2]);J().Set("");I().Set(0);}
function L(){ const hK=M().Get();const hL=H().Get();const hM=G().Get();const hN=Q().Get();const hO=P(hK, hL, hM, hN[0], hN[1]);Q().Set([hO[0], hO[1]]);M().Set(hO[2]);H().Set("");G().Set(0);}
function M(){ return u0038.totalE;}
function N(){ return u0038.totalG;}
function O(){ return u0038.storage_i;}
function P(hK, hL, hM, hN, hO){ return[cb(hN, b8([hL])), cb(hO, b8([hM])), hK+hM];}
function Q(){ return u0038.storage_e;}
let R=hB((hK) => class hL extends m { static { R=hK(this);} });
let S=hB((hK) => class hL extends m { static { S=hK(this);} doc;allVars;anchorRoot;get Doc(){ return this.doc;} SetAnchorRoot(hM){ this.anchorRoot=hM;} constructor(hM, hN){ super();this.doc=hN;this.allVars=hM.$==0?hM.$0:j("Should not happen");this.anchorRoot=null;} });
let T=hB((hK) => { hE(o);return class hL extends o { static { T=hK(this);} name;fillWith;get Name(){ return this.name;} get Value(){ return this.fillWith;} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let U=hB((hK) => { hE(o);return class hL extends o { static { U=hK(this);} name;fillWith;get Name(){ return this.name;} get Value(){ return this.fillWith;} get AsChoiceView(){ return f4(this.fillWith);} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
function V(hK, hL){ if(hK===hL)return true;else { const hM=typeof hK;if(hM=="object"){ if(hK===null||hK===void 0||hL===null||hL===void 0||!V(typeof hL, "object"))return false;else if("Equals"in hK)return hK.Equals(hL);else if("Equals"in hL)return false;else if(hK instanceof Array&&hL instanceof Array)return W(hK, hL);else if(hK instanceof Date&&hL instanceof Date)return X(hK, hL);else { const hN=[true];let hO;for(var hQ in hK)if(((hR) => { hN[0]=!hK.hasOwnProperty(hR)||hL.hasOwnProperty(hR)&&V(hK[hR], hL[hR]);return!hN[0];})(hQ))break;if(hN[0]){ let hP;for(var hR in hL)if(((hS) => { hN[0]=!hL.hasOwnProperty(hS)||hK.hasOwnProperty(hS);return!hN[0];})(hR))break;} return hN[0];} } else return hM=="function"&&("$Func"in hK?hK.$Func===hL.$Func&&hK.$Target===hL.$Target:"$Invokes"in hK&&"$Invokes"in hL&&W(hK.$Invokes, hL.$Invokes));} }
function W(hK, hL){ let hM;let hN;if(g(hK)===g(hL)){ hM=true;hN=0;while(hM&&hN<g(hK)){!V(f(hK, hN), f(hL, hN))?hM=false:void 0;hN=hN+1;} return hM;} else return false;}
function X(hK, hL){ return hK.getTime()===hL.getTime();}
function Y(hK){ const hL=typeof hK;return hL=="function"?0:hL=="boolean"?hK?1:0:hL=="number"?hK:hL=="string"?Z(hK):hL=="object"?hK==null?0:hK instanceof Array?u0030(hK):u0031(hK):0;}
function Z(hK){ let hL;if(hK===null)return 0;else { hL=5381;for(let hM=0, hN=hK.length-1;hM<=hN;hM++)hL=u0032(hL, hK[hM].charCodeAt());return hL;} }
function u0030(hK){ let hL=-34948909;for(let hM=0, hN=g(hK)-1;hM<=hN;hM++)hL=u0032(hL, Y(f(hK, hM)));return hL;}
function u0031(hK){ if("GetHashCode"in hK)return hK.GetHashCode();else { const hL=[0];let hM;for(var hN in hK)if(((hO) => { hL[0]=u0032(u0032(hL[0], Z(hO)), Y(hK[hO]));return false;})(hN))break;return hL[0];} }
function u0032(hK, hL){ return(hK<<5)+hK+hL;}
function u0033(hK, hL){ if(hK===hL)return 0;else { const hM=typeof hK;switch(hM=="function"?1:hM=="boolean"?2:hM=="number"?2:hM=="string"?2:hM=="object"?3:0){ case 0:return typeof hL=="undefined"?0:-1;case 1:return j("Cannot compare function values.");case 2:return hK<hL?-1:1;case 3:if(hK===null)return -1;else if(hL===null)return 1;else if("CompareTo"in hK)return hK.CompareTo(hL);else if("CompareTo0"in hK)return hK.CompareTo0(hL);else if(hK instanceof Array&&hL instanceof Array)return u0034(hK, hL);else if(hK instanceof Date&&hL instanceof Date)return u0035(hK, hL);else { const hN=[0];let hO;for(var hQ in hK)if(((hR) =>!hK.hasOwnProperty(hR)?false:!hL.hasOwnProperty(hR)?(hN[0]=1,true):(hN[0]=u0033(hK[hR], hL[hR]),hN[0]!==0))(hQ))break;if(hN[0]===0){ let hP;for(var hR in hL)if(((hS) =>!hL.hasOwnProperty(hS)?false:!hK.hasOwnProperty(hS)&&(hN[0]=-1,true))(hR))break;} return hN[0];} break;} } }
function u0034(hK, hL){ let hM;let hN;if(g(hK)<g(hL))return -1;else if(g(hK)>g(hL))return 1;else { hM=0;hN=0;while(hM===0&&hN<g(hK)){ hM=u0033(f(hK, hN), f(hL, hN));hN=hN+1;} return hM;} }
function u0035(hK, hL){ return u0033(hK.getTime(), hL.getTime());}
function u0036(){ return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(new RegExp("[xy]", "g"), (hK) => { const hL=Math.random()*16|0;const hM=hK=="x"?hL:hL&3|8;return hM.toString(16);});}
function u0037(hK, hL){ return{Parse:hK, Write:hL};}
let u0038=hB((hK) => class hL { static { u0038=hK(this);} static currentPage;static router;static stockModel;static initialStockData;static random;static stockA;static stockN;static stockP;static totalExpensesView;static totalIncomeView;static balanceView;static storage_e;static storage_i;static totalE;static loss;static expensegroup;static totalG;static gain;static incomegroup;static { this.incomegroup=b4.Create_1("");this.gain=b4.Create_1(0);this.totalG=b4.Create_1(0);this.expensegroup=b4.Create_1("");this.loss=b4.Create_1(0);this.totalE=b4.Create_1(0);this.storage_i=b4.Create_1([b2.Empty, b2.Empty]);this.storage_e=b4.Create_1([b2.Empty, b2.Empty]);this.balanceView=$((hP, hQ) =>(hP-hQ).toFixed(2), N().View, M().View);this.totalIncomeView=u0039((hP) => hP.toFixed(2), N().View);this.totalExpensesView=u0039((hP) => hP.toFixed(2), M().View);const hM=[b4.Create_1(""), b4.Create_1(0), b4.Create_1(0)];this.stockP=hM[2];this.stockN=hM[0];this.stockA=hM[1];this.random=new b3();this.initialStockData=b2.Empty;const hN=b5((hP) => hP.Name, y());let hO=(ba((hP) => { x(b7(hP));}, hN.v),hN);this.stockModel=hO;this.router=bU();this.currentPage=cf({$:0}, d());} });
function u0039(hK, hL){ return bb(() => cj(hK, hL()));}
function $(hK, hL, hM){ return bb(() => ck(hK, hL(), hM()));}
function ba(hK, hL){ function hM(){ cl(hL(), hK, () => { ep().Fork(hM);});} ep().Fork(hM);}
function bb(hK){ const hL={c:null, o:hK};return() => { let hM=hL.c;if(hM===null){ hM=hL.o();hL.c=hM;const hN=hM.s;if(hN!=null&&hN.$==0)hL.o=null;else cm(hM, () => { hL.c=null;});return hM;} else return hM;};}
function bc(hK, hL){ return bd(u0039(hK, hL));}
function bd(hK){ return bb(() => cv(hK()));}
function be(hK, hL){ return bf((hM) => hM, hK, hL);}
function bf(hK, hL, hM){ const hN=[new dn("New_5")];return u0039((hO) => { const hP=hN[0];const hQ=new dn("New_5");const hR=f7((hS) => { const hT=hK(hS);const hU=hP.ContainsKey(hT)?hP.Item(hT):hL(hS);hQ.set_Item(hT, hU);return hU;}, dr(hO));hN[0]=hQ;return hR;}, hM);}
function bg(hK){ const hL={s:eH(hK)};return() => hL;}
function bh(hK, hL, hM, hN){ return bb(() => cw(hK, hL(), hM(), hN()));}
function bi(hK){ return bb(() => cx(bq((hL) => hL(), hK)));}
function bj(hK, hL){ return bb(() => cy(hK(), hL()));}
let bk=hB((hK) => class hL extends m { static { bk=hK(this);} key;u0076ar;storage;v;it;RemoveByKey(hM){ this.u0076ar.Set(this.storage.SRemoveIf((hN) => V(this.key(hN), hM), this.u0076ar.Get()));this.ObsoleteKey(hM);} ObsoleteKey(hM){ let hN;const hO=(hN=null,[this.it.TryGetValue(hM, {get:() => hN, set:(hP) => { hN=hP;}}), hN]);if(hO[0]){ ea(hO[1]);this.it.RemoveKey(hM);} } Append(hM){ const hN=this.u0076ar.Get();const hO=this.key(hM);const hP=dq((hQ) => V(this.key(hQ), hO), hN);if(hP!=null&&hP.$==1)this.u0076ar.Set(this.storage.SSetAt(hP.$0, hM, hN));else this.u0076ar.Set(this.storage.SAppend(hM, hN));this.ObsoleteKey(hO);} Iter(hM){ dw(hM, this.u0076ar.Get());} UpdateBy(hM, hN){ const hO=this.u0076ar.Get();const hP=dq((hS) => V(this.key(hS), hN), hO);if(hP!=null&&hP.$==1){ const hQ=hP.$0;const hR=hM(f(hO, hQ));if(hR!=null&&hR.$==1){ this.u0076ar.Set(this.storage.SSetAt(hQ, hR.$0, hO));this.ObsoleteKey(hN);} } else void 0;} GetEnumerator(){ return ev(this.u0076ar.Get());} GetEnumerator0(){ return ey(this.u0076ar.Get());} static New(hM, hN){ return new this("New", hM, hN);} static New_3(hM, hN, hO){ return new this("New_3", hM, hN, hO);} constructor(hM, hN, hO, hP){ let hQ;let hR;if(hM=="New"){ hQ=hN;hR=hO;hM="New_3";hN=hQ;hO=b4.Create_1(dr(bt(hQ, hR.SInit())));hP=hR;} if(hM=="New_3"){ const hS=hN;const hT=hO;const hU=hP;super();this.key=hS;this.u0076ar=hT;this.storage=hU;this.v=u0039((hV) => hV.slice(), this.u0076ar.View);this.it=new dn("New_5");} } });
function bl(hK, hL){ let hM=0;const hN=ev(hL);try { while(hN.MoveNext())hM=hM+hK(hN.Current);} finally { if(typeof hN=="object"&&a(hN))hN.Dispose();} return hM;}
function bm(hK, hL){ return{GetEnumerator:() => { const hM=ev(hK);const hN=[true];return new eC(hM, null, (hO) => { if(hO.s.MoveNext()){ hO.c=hO.s.Current;return true;} else { const hP=hO.s;if(!V(hP, null))hP.Dispose();hO.s=null;return hN[0]&&(hN[0]=false,hO.s=ev(hL),hO.s.MoveNext()?(hO.c=hO.s.Current,true):(hO.s.Dispose(),hO.s=null,false));} }, (hO) => { const hP=hO.s;if(!V(hP, null))hP.Dispose();});}};}
function bn(hK, hL){ let hM=0;const hN=ev(hL);try { while(hN.MoveNext()){ hK(hM, hN.Current);hM=hM+1;} } finally { if(typeof hN=="object"&&a(hN))hN.Dispose();} }
function bo(hK, hL){ return bu(bq(hK, hL));}
function bp(hK){ return bv((hL, hM) =>[hL, hM], hK);}
function bq(hK, hL){ return{GetEnumerator:() => { const hM=ev(hL);return new eC(null, null, (hN) => hM.MoveNext()&&(hN.c=hK(hM.Current),true), () => { hM.Dispose();});}};}
function br(hK, hL){ const hM=ev(hL);try { let hN=true;let hO=0;while(hN&&hM.MoveNext())if(hK(hM.Current))hN=false;else hO=hO+1;return hN?null:bV(hO);} finally { if(typeof hM=="object"&&a(hM))hM.Dispose();} }
function bs(hK, hL){ const hM=ev(hL);try { let hN=null;while(V(hN, null)&&hM.MoveNext())hN=hK(hM.Current);return hN;} finally { if(typeof hM=="object"&&a(hM))hM.Dispose();} }
function bt(hK, hL){ return{GetEnumerator:() => { const hM=ev(hL);const hN=new do_1("New_3");return new eC(null, null, (hO) => { let hP;let hQ;if(hM.MoveNext()){ hP=hM.Current;hQ=hN.SAdd(hK(hP));while(!hQ&&hM.MoveNext()){ hP=hM.Current;hQ=hN.SAdd(hK(hP));} return hQ&&(hO.c=hP,true);} else return false;}, () => { hM.Dispose();});}};}
function bu(hK){ return{GetEnumerator:() => { const hL=ev(hK);function hM(hN){ while(true){ const hO=hN.s;if(V(hO, null)){ if(hL.MoveNext()){ hN.s=ev(hL.Current);hN=hN;} else { hL.Dispose();return false;} } else if(hO.MoveNext()){ hN.c=hO.Current;return true;} else { hN.Dispose();hN.s=null;hN=hN;} } } return new eC(null, null, hM, (hN) => { const hO=hN.s;if(!V(hO, null))hO.Dispose();if(!V(hL, null))hL.Dispose();});}};}
function bv(hK, hL){ return by(hK, bz((hM) => hM), hL);}
function bw(hK){ const hL=ev(hK);try { return hL.MoveNext()?hL.Current:gD();} finally { if(typeof hL=="object"&&a(hL))hL.Dispose();} }
function bx(hK, hL, hM){ let hN=hL;const hO=ev(hM);try { while(hO.MoveNext())hN=hK(hN, hO.Current);return hN;} finally { if(typeof hO=="object"&&a(hO))hO.Dispose();} }
function by(hK, hL, hM){ return{GetEnumerator:() => { const hN=ev(hL);const hO=ev(hM);return new eC(null, null, (hP) => hN.MoveNext()&&hO.MoveNext()&&(hP.c=hK(hN.Current, hO.Current),true), () => { hN.Dispose();hO.Dispose();});}};}
function bz(hK){ return{GetEnumerator:() => new eC(0, null, (hL) => { hL.c=hK(hL.s);hL.s=hL.s+1;return true;}, void 0)};}
function bA(hK, hL, hM){ return!bC((hN, hO) =>!hK(hN, hO), hL, hM);}
function bB(hK, hL){ const hM=ev(hL);try { while(hM.MoveNext())hK(hM.Current);} finally { if(typeof hM=="object"&&a(hM))hM.Dispose();} }
function bC(hK, hL, hM){ const hN=ev(hL);try { const hO=ev(hM);try { let hP=false;while(!hP&&hN.MoveNext()&&hO.MoveNext())hP=hK(hN.Current, hO.Current);return hP;} finally { if(typeof hO=="object"&&a(hO))hO.Dispose();} } finally { if(typeof hN=="object"&&a(hN))hN.Dispose();} }
function bD(hK){ return bF(() => dr(hK).slice().reverse());}
function bE(hK, hL){ return{GetEnumerator:() => new eC(hL, null, (hM) => { const hN=hK(hM.s);return hN==null?false:(hM.c=hN.$0[0],hM.s=hN.$0[1],true);}, void 0)};}
function bF(hK){ return{GetEnumerator:() => ev(hK())};}
function bG(hK){ const hL=ev(hK);try { if(!hL.MoveNext())bJ();let hM=hL.Current;while(hL.MoveNext()){ const hN=hL.Current;if(u0033(hN, hM)===1)hM=hN;} return hM;} finally { if(typeof hL=="object"&&a(hL))hL.Dispose();} }
function bH(hK){ return bt((hL) => hL, hK);}
function bI(hK, hL){ return bK(hK, bz(hL));}
function bJ(){ return j("The input sequence was empty.");}
function bK(hK, hL){ hK<0?gH():void 0;return{GetEnumerator:() => { const hM=[ev(hL)];return new eC(0, null, (hN) => { hN.s=hN.s+1;if(hN.s>hK)return false;else { const hO=hM[0];return V(hO, null)?gD():hO.MoveNext()?(hN.c=hO.Current,hN.s===hK?(hO.Dispose(),hM[0]=null):void 0,true):(hO.Dispose(),hM[0]=null,gD());} }, () => { const hN=hM[0];if(!V(hN, null))hN.Dispose();});}};}
function bL(hK, hL){ return!bM((hM) =>!hK(hM), hL);}
function bM(hK, hL){ const hM=ev(hL);try { let hN=false;while(!hN&&hM.MoveNext())hN=hK(hM.Current);return hN;} finally { if(typeof hM=="object"&&a(hM))hM.Dispose();} }
function bN(hK, hL, hM){ const hN=ev(hL);try { const hO=ev(hM);try { let hP=0;let hQ=true;while(hQ&&hP===0)if(hN.MoveNext())hP=hO.MoveNext()?hK(hN.Current, hO.Current):1;else if(hO.MoveNext())hP=-1;else hQ=false;return hP;} finally { if(typeof hO=="object"&&a(hO))hO.Dispose();} } finally { if(typeof hN=="object"&&a(hN))hN.Dispose();} }
function bO(hK, hL, hM, hN){ return{Name:hK, Amount:hL, Price:hM, LastPrice:hN};}
function bP(hK, hL, hM, hN){ return new cL(hL, (hO) =>(hP) => { const hQ=hM();hQ.SetAnchorRoot(hO);return hN({Vars:hQ, Anchors:hQ, Target:hO, Event:hP});});}
function bQ(hK, hL, hM){ const hN=new dn("New_5");const hO=new do_1("New_3");const hP=ev(hL);try { while(hP.MoveNext()){ const hQ=hP.Current;const hR=hQ.Name;hO.SAdd(hR);hN.set_Item(hR, hQ);} } finally { if(typeof hP=="object"&&a(hP))hP.Dispose();} return[bm(hL, dp((hS) => { const hT=hS[0];const hU=hS[1];const hV=hS[2];if(hO.Contains(hT))return null;else { const hW=hU===0?dH.GetOrAddHoleFor(hK, hT, () => { const hX=hV==null?null:bV(hV.$0);let hY=b4.Create_1(hX==null?"":hX.$0);return new cK(hT, hY);}):hU===1?dH.GetOrAddHoleFor(hK, hT, () => { const hX=hV==null?null:bV(hV.$0);let hY=b4.Create_1(hX==null?0:hX.$0);return new cJ(hT, hY);}):hU===2?dH.GetOrAddHoleFor(hK, hT, () => { const hX=hV==null?null:bV(hV.$0);let hY=b4.Create_1(hX==null?false:hX.$0);return new dJ(hT, hY);}):hU===3?dH.GetOrAddHoleFor(hK, hT, () => { const hX=hV==null?null:bV(hV.$0);let hY=b4.Create_1(hX==null?-8640000000000000:hX.$0);return new dK(hT, hY);}):hU===4?dH.GetOrAddHoleFor(hK, hT, () => new dL(hT, b4.Create_1([]))):hU===5?dH.GetOrAddHoleFor(hK, hT, () => new dM(hT, b4.Create_1(bV(globalThis.document.querySelector("[ws-dom="+hT+"]"))))):hU===6?dH.GetOrAddHoleFor(hK, hT, () => { const hX=hV==null?null:bV(hV.$0);let hY=b4.Create_1(hX==null?[]:hX.$0);return new dO(hT, hY);}):j("Invalid value type");hN.set_Item(hT, hW);return bV(hW);} }, hM)), {$:0, $0:hN}];}
function bR(hK){ dR("index");return hK?dS("index", bV("stocklist"), hK):void 0;}
function bS(hK){ dR("index");return hK?dS("index", bV("stockportfolio"), hK):void 0;}
function bT(hK){ dR("index");return hK?dS("index", bV("moneytracking"), hK):void 0;}
function bU(){ return ez(void 0, [[null, [[null, []]], []], [null, [[null, ["counter"]]], []]]);}
function bV(hK){ return{$:1, $0:hK};}
function bW(hK){ const hL={};const hM=ev(hK);try { while(hM.MoveNext()){ const hN=hM.Current;hL[hN[0]]=hN[1];} } finally { if(typeof hM=="object"&&a(hM))hM.Dispose();} return hL;}
let bX=hB((hK) => class hL extends m { static { bX=hK(this);} docNode;updates;static EmbedView(hM){ const hN=cY();return bX.Mk(di(hN), u0039(() => { }, bc((hO) => { cZ(hN, hO.docNode);return hO.updates;}, hM)));} static Mk(hM, hN){ return new hL(hM, hN);} static Convert(hM, hN){ return bX.Flatten(be(hM, hN));} static RunInPlace(hM, hN, hO){ const hP=c0(hN, hO.docNode);ba(ff()||fm()?fn(c1(hM, hP, hO.docNode)):() => { c2(hM, hP, hO.docNode);}, hO.updates);} static Flatten(hM){ return bX.EmbedView(u0039(bX.Concat, hM));} static get Empty(){ return bX.Mk(null, bg());} static Concat(hM){ return f6(bX.Empty, bX.Append, f8(hM));} static TextNode(hM){ return bX.Mk(dk(globalThis.document.createTextNode(hM)), bg());} static TextView(hM){ const hN=c$();return bX.Mk(dl(hN), u0039((hO) => { da(hN, hO);}, hM));} static Append(hM, hN){ return bX.Mk(dm(hM.docNode, hN.docNode), bj(hM.updates, hN.updates));} constructor(hM, hN){ super();this.docNode=hM;this.updates=hN;} });
function bY(hK, hL){ const hM=bZ(hK, hL);return hM==null?"":hM.$0.ToLink();}
function bZ(hK, hL){ const hM=hK.Write(hL);return hM==null?null:bV(d$.Combine(hM.$0));}
function b0(hK, hL){ return bs((hM) => hM[0].Segments.$==0?bV(hM[1]):null, hK.Parse(hL));}
function b1(hK, hL){ return"#"+bY(hK, hL);}
let b2=hB((hK) => class hL { static { b2=hK(this);} static Empty=hF(b2, {$:0});static Cons(hM, hN){ return hF(hL, {$:1, $0:hM, $1:hN});} GetEnumerator(){ return new eC(this, null, (hM) => { const hN=hM.s;return hN.$==0?false:(hM.c=hN.$0,hM.s=hN.$1,true);}, void 0);} });
let b3=hB((hK) => class hL extends m { static { b3=hK(this);} });
let b4=hB((hK) => class hL extends m { static { b4=hK(this);} static Create_1(hM){ return new eb(false, {s:eG(hM, [])}, hM);} static { } });
function b5(hK, hL){ return b6(hK, ec(dr(hL)));}
function b6(hK, hL){ return new bk("New", hK, hL);}
function b7(hK){ if(hK instanceof b2)return hK;else if(hK instanceof Array)return b8(hK);else { const hL=ev(hK);try { let hM;let hN=hL.MoveNext();if(!hN)return b2.Empty;else { const hO=hF(b2, {$:1});hM=hO;while(hN){ hM.$0=hL.Current;if(hL.MoveNext()){ const hP=hF(b2, {$:1});hM=(hM.$1=hP,hP);} else hN=false;} hM.$1=b2.Empty;return hO;} } finally { if(typeof hL=="object"&&a(hL))hL.Dispose();} } }
function b8(hK){ let hL=b2.Empty;for(let hM=g(hK)-1, hN=0;hM>=hN;hM--)hL=b2.Cons(f(hK, hM), hL);return hL;}
function b9(hK, hL){ let hM;let hN;let hO;if(hL.$==0)return hL;else { const hP=hF(b2, {$:1});hM=hP;hN=hL;hO=true;while(hO){ hM.$0=hK(hN.$0);hN=hN.$1;if(hN.$==0)hO=false;else { const hQ=hF(b2, {$:1});hM=(hM.$1=hQ,hQ);} } hM.$1=b2.Empty;return hP;} }
function b_(hK, hL){ let hM=hL;while(hM.$==1){ hK(cc(hM));hM=cd(hM);} }
function b$(hK, hL){ return b8(dv(hK, hL));}
function ca(hK){ let hL=b2.Empty;let hM=hK;while(hM.$==1){ hL=b2.Cons(hM.$0, hL);hM=hM.$1;} return hL;}
function cb(hK, hL){ let hM;let hN;let hO;if(hK.$==0)return hL;else if(hL.$==0)return hK;else { const hP=hF(b2, {$:1});hM=hP;hN=hK;hO=true;while(hO){ hM.$0=hN.$0;hN=hN.$1;if(hN.$==0)hO=false;else { const hQ=hF(b2, {$:1});hM=(hM.$1=hQ,hQ);} } hM.$1=hL;return hP;} }
function cc(hK){ return hK.$==1?hK.$0:ce();}
function cd(hK){ return hK.$==1?hK.$1:ce();}
function ce(){ return j("The input list was empty.");}
function cf(hK, hL){ const hM=b4.Create_1(void 0);cg(hM, hK, hL);return hM;}
function cg(hK, hL, hM){ const hN=(hQ) => b0(hM, d$.FromHash(hQ, bV(true)));const hO=() => ch(hN, hL);const hP=(hQ) => { if(!V(hK.Get(), hQ))hK.Set(hQ);};hP(hO());globalThis.addEventListener("popstate", () => hP(hO()), false);globalThis.addEventListener("hashchange", () => hP(hO()), false);globalThis.document.body.addEventListener("click", (hQ) => { let hR;const hS=ci(hQ.target);if(hS==null)hR=null;else { const hT=hS.$0;hR=cN(hT, "#")?hN(hT):null;} return hR==null?null:(hP(hR.$0),hQ.preventDefault());}, false);ba((hQ) => { if(!V(hQ, hO())){ const hR=b1(hM, hQ);globalThis.history.pushState(null, null, hR);} }, hK.View);}
function ch(hK, hL){ const hM=globalThis.location.hash;const hN=hK(hM);return hN==null?((((hO) =>(hP) => hO("Failed to parse route: "+ft(hP)))((hO) => { console.log(hO);}))(hM),hL):hN.$0;}
function ci(hK){ while(true){ if(hK.tagName=="A")return dI(hK.getAttribute("href"));else if(hK===globalThis.document.body)return null;else hK=hK.parentNode;} }
function cj(hK, hL){ const hM=hL.s;if(hM!=null&&hM.$==0)return{s:eH(hK(hM.$0))};else { const hN={s:eI([], [])};cn(hL, (hO) => { co(hN, hL, hK(hO));}, hN);return hN;} }
function ck(hK, hL, hM){ const hN=hL.s;const hO=hM.s;if(hN!=null&&hN.$==0)return hO!=null&&hO.$==0?{s:eH(hK(hN.$0, hO.$0))}:cp(hK, hN.$0, hM);else if(hO!=null&&hO.$==0)return cq(hK, hO.$0, hL);else { const hP={s:eI([], [])};const hQ=() => { const hR=hP.s;if(!(hR!=null&&hR.$==0||hR!=null&&hR.$==2)){ const hS=cr(hL);const hT=cr(hM);if(hS!=null&&hS.$==1)if(hT!=null&&hT.$==1)if(hS.$0[1]&&hT.$0[1])cs(hP, hK(hS.$0[0], hT.$0[0]));else ct(hP, hK(hS.$0[0], hT.$0[0]));} };cn(hL, hQ, hP);cn(hM, hQ, hP);return hP;} }
function cl(hK, hL, hM){ const hN=hK.s;if(hN==null)hM();else hN!=null&&hN.$==2?(hN.$1.push(hM),hL(hN.$0)):hN!=null&&hN.$==3?(hN.$0.push(hL),hN.$1.push(hM)):hL(hN.$0);}
function cm(hK, hL){ const hM=hK.s;if(hM==null)hL();else hM!=null&&hM.$==2?hM.$1.push(hL):hM!=null&&hM.$==3?hM.$1.push(hL):void 0;}
function cn(hK, hL, hM){ const hN=hK.s;if(hN==null)ea(hM);else hN!=null&&hN.$==2?(cu(hN.$1, hM),hL(hN.$0)):hN!=null&&hN.$==3?(hN.$0.push(hL),cu(hN.$1, hM)):hL(hN.$0);}
function co(hK, hL, hM){ const hN=hL.s;if(hN!=null&&hN.$==0)cs(hK, hM);else ct(hK, hM);}
function cp(hK, hL, hM){ return cj((hN) => hK(hL, hN), hM);}
function cq(hK, hL, hM){ return cj((hN) => hK(hN, hL), hM);}
function cr(hK){ const hL=hK.s;return hL!=null&&hL.$==0?bV([hL.$0, true]):hL!=null&&hL.$==2?bV([hL.$0, false]):null;}
function cs(hK, hL){ const hM=hK.s;if(hM!=null&&hM.$==3){ hK.s=eH(hL);const hN=hM.$0;for(let hO=0, hP=g(hN)-1;hO<=hP;hO++)(f(hN, hO))(hL);} else void 0;}
function ct(hK, hL){ const hM=hK.s;if(hM!=null&&hM.$==3){ hK.s=eG(hL, hM.$1);const hN=hM.$0;for(let hO=0, hP=g(hN)-1;hO<=hP;hO++)(f(hN, hO))(hL);} else void 0;}
function cu(hK, hL){ hK.push(hL);if(hK.length%20===0){ const hM=hK.slice(0);gC(hK);for(let hO=0, hP=g(hM)-1;hO<=hP;hO++){ const hN=f(hM, hO);if(typeof hN=="object")(((hQ) => { if(hQ.s)hK.push(hQ);})(hN));else(((hQ) => { hK.push(hQ);})(hN));} } else void 0;}
function cv(hK){ const hL={s:eI([], [])};cn(hK, (hM) => { const hN=hM();cn(hN, (hO) => { let hP;const hQ=hN.s;if(hQ!=null&&hQ.$==0){ const hR=hK.s;hP=hR!=null&&hR.$==0;} else hP=false;if(hP)cs(hL, hO);else ct(hL, hO);}, hL);}, hL);return hL;}
function cw(hK, hL, hM, hN){ const hO=hL.s;const hP=hM.s;const hQ=hN.s;if(hO!=null&&hO.$==0)return hP!=null&&hP.$==0?hQ!=null&&hQ.$==0?{s:eH(hK(hO.$0, hP.$0, hQ.$0))}:cA(hK, hO.$0, hP.$0, hN):hQ!=null&&hQ.$==0?cB(hK, hO.$0, hQ.$0, hM):cC(hK, hO.$0, hM, hN);else if(hP!=null&&hP.$==0)return hQ!=null&&hQ.$==0?cD(hK, hP.$0, hQ.$0, hL):cE(hK, hP.$0, hL, hN);else if(hQ!=null&&hQ.$==0)return cF(hK, hQ.$0, hL, hM);else { const hR={s:eI([], [])};const hS=() => { const hT=hR.s;if(!(hT!=null&&hT.$==0||hT!=null&&hT.$==2)){ const hU=cr(hL);const hV=cr(hM);const hW=cr(hN);if(hU!=null&&hU.$==1)if(hV!=null&&hV.$==1)if(hW!=null&&hW.$==1)if(hU.$0[1]&&hV.$0[1]&&hW.$0[1])cs(hR, hK(hU.$0[0], hV.$0[0], hW.$0[0]));else ct(hR, hK(hU.$0[0], hV.$0[0], hW.$0[0]));} };cn(hL, hS, hR);cn(hM, hS, hR);cn(hN, hS, hR);return hR;} }
function cx(hK){ const hL=dr(hK);if(hL.length==0)return{s:eH([])};else { const hM={s:eI([], [])};const hN=[g(hL)-1];const hO=() => { if(hN[0]===0){ const hP=dC((hQ) => { const hR=hQ.s;return hR!=null&&hR.$==0?hR.$0:hR!=null&&hR.$==2?hR.$0:j("value not found by View.Sequence");}, hL);if(du((hQ) => { const hR=hQ.s;return hR!=null&&hR.$==0;}, hL))cs(hM, hP);else ct(hM, hP);} else hN[0]=hN[0]-1;};dw((hP) => { cn(hP, hO, hM);}, hL);return hM;} }
function cy(hK, hL){ const hM=hK.s;const hN=hL.s;if(hM!=null&&hM.$==0)return hN!=null&&hN.$==0?{s:eH(null)}:hL;else if(hN!=null&&hN.$==0)return hK;else { const hO={s:eI([], [])};const hP=() => { const hQ=hO.s;if(!(hQ!=null&&hQ.$==0||hQ!=null&&hQ.$==2)){ const hR=cr(hK);const hS=cr(hL);if(hR!=null&&hR.$==1)if(hS!=null&&hS.$==1)if(hR.$0[1]&&hS.$0[1])cs(hO, null);else ct(hO, null);} };cn(hK, hP, hO);cn(hL, hP, hO);return hO;} }
function cz(hK){ const hL=hK.s;if(hL==null)return hK;else if(hL!=null&&hL.$==2){ const hM={s:eG(hL.$0, [])};cG(hK, hM);return hM;} else if(hL!=null&&hL.$==3){ const hN={s:eI([], [])};cn(hK, (hO) => { co(hN, hK, hO);}, hN);return hN;} else return hK;}
function cA(hK, hL, hM, hN){ return cj((hO) => hK(hL, hM, hO), hN);}
function cB(hK, hL, hM, hN){ return cj((hO) => hK(hL, hO, hM), hN);}
function cC(hK, hL, hM, hN){ return ck((hO, hP) => hK(hL, hO, hP), hM, hN);}
function cD(hK, hL, hM, hN){ return cj((hO) => hK(hO, hL, hM), hN);}
function cE(hK, hL, hM, hN){ return ck((hO, hP) => hK(hO, hL, hP), hM, hN);}
function cF(hK, hL, hM, hN){ return ck((hO, hP) => hK(hO, hP, hL), hM, hN);}
function cG(hK, hL){ const hM=hK.s;if(hM==null)ea(hL);else hM!=null&&hM.$==2?cu(hM.$1, hL):hM!=null&&hM.$==3?cu(hM.$1, hL):void 0;}
function cH(hK, hL){ return hu(hK, -2147483648, 2147483647, hL);}
let cI=hB((hK) => { hE(o);return class hL extends o { static { cI=hK(this);} name;fillWith;get Name(){ return this.name;} ForTextView(){ return bV(this.fillWith);} get AsChoiceView(){ return f5(this.fillWith);} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let cJ=hB((hK) => { hE(o);return class hL extends o { static { cJ=hK(this);} name;fillWith;get Name(){ return this.name;} ForTextView(){ return bV(u0039(String, this.fillWith.View));} AddAttribute(hM, hN){(hM(hN))(fT(this.fillWith));} get AsChoiceView(){ return f5(u0039(String, this.fillWith.View));} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let cK=hB((hK) => { hE(o);return class hL extends o { static { cK=hK(this);} name;fillWith;get Name(){ return this.name;} ForTextView(){ return bV(this.fillWith.View);} AddAttribute(hM, hN){(hM(hN))(fU(this.fillWith));} get AsChoiceView(){ return f5(u0039(String, this.fillWith.View));} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let cL=hB((hK) => { hE(o);return class hL extends o { static { cL=hK(this);} name;fillWith;get Name(){ return this.name;} get Value(){ return this.fillWith;} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
function cM(hK){ return hK==null||(new RegExp("^\\s*$")).test(hK);}
function cN(hK, hL){ return hK.substring(0, hL.length)==hL;}
function cO(hK, hL){ return dr(hL).join(hK);}
function cP(hK, hL, hM){ return cR(hK, new RegExp("["+cS(hL.join(""))+"]"), hM);}
function cQ(hK, hL, hM){ return hK.substr(hL, hM);}
function cR(hK, hL, hM){ return hM===1?dz((hN) => hN!=="", cV(hK, hL)):cV(hK, hL);}
function cS(hK){ return hK.replace(new RegExp("[-\\/\\\\^$*+?.()|[\\]{}]", "g"), "\\$&");}
function cT(hK){ return hK==null||hK=="";}
function cU(hK, hL){ return hL.join(hK);}
function cV(hK, hL){ return hK.split(hL);}
function cW(hK, hL){ return bL(hK, cX(hL));}
function cX(hK){ return hK==null?"":hK;}
function cY(){ return{Current:null, Dirty:false};}
function cZ(hK, hL){ hK.Current=hL;hK.Dirty=true;}
function c0(hK, hL){ return ga(gb(), c5(hK, fD(), hL));}
function c1(hK, hL, hM){ if(ff()){ const hN=null;return ed(() => { const hO=gc(hM);const hP=c9(hL, hO);const hQ=c8(hL, hO);return ef(fg(fh(hP, c7(hL, hO))), () => ef(c6(hK, hL), () => ef(fg(hQ), () => { hL.PreviousNodes=hO;return ej(null);})));});} else return c6(hK, hL);}
function c2(hK, hL, hM){ const hN=gc(hM);c_(hK, hL.Top);hL.PreviousNodes=hN;}
function c3(hK, hL){ db(hK, hL, null);}
function c4(hK, hL){ const hM=hK.parentNode;const hN=globalThis.document.createTextNode("");hM.insertBefore(hN, hK);dc(hK, hL);return hN;}
function c5(hK, hL, hM){ c3(hK, hM);const hN=fx(hK, hL);return eU.New(hN, hM, null, hK, eJ(), hG(hN.OnAfterRender));}
function c6(hK, hL){ if(fm()){ const hM=(hN) => { requestAnimationFrame(() => { c_(hK, hL.Top);hN();});};return er((hN, hO, hP) => hM.apply(null, [hN, hO, hP]));} else { c_(hK, hL.Top);return ej(null);} }
function c7(hK, hL){ return fk(dC((hM) => fF(hM.Attr), gg(gf(hL, ge((hM) => fE(hM.Attr), hK.PreviousNodes)))));}
function c8(hK, hL){ return fk(dC((hM) => fH(hM.Attr), gg(gf(hK.PreviousNodes, ge((hM) => fG(hM.Attr), hL)))));}
function c9(hK, hL){ const hM=(hO) => fI(hO.Attr);const hN=(hO) => ge(hM, hO);return fk(dC((hO) => fJ(hO.Attr), gg(gh(hN(hK.PreviousNodes), hN(hL)))));}
function c_(hK, hL){!hK?dd(hL):void 0;de(hL.Children);df(hL);}
function c$(){ return{Text:globalThis.document.createTextNode(""), Dirty:false, Value:""};}
function da(hK, hL){ hK.Value=hL;hK.Dirty=true;}
function db(hK, hL, hM){ while(true){ if(hL!=null&&hL.$==1)return dg(hK, hL.$0.El, hM);else if(hL!=null&&hL.$==2){ const hN=hL.$0;hN.Dirty=false;hL=hN.Current;} else if(hL==null)return hM;else if(hL!=null&&hL.$==4)return dg(hK, hL.$0.Text, hM);else if(hL!=null&&hL.$==5)return dg(hK, hL.$0, hM);else if(hL!=null&&hL.$==6)return dD((hQ, hR) =>((((hS) =>(hT) =>(hU) => hT==null||hT.constructor===Object?db(hS, hT, hU):dg(hS, hT, hU))(hK))(hQ))(hR), hL.$0.Els, hM);else { const hO=hL.$1;const hP=hL.$0;hL=hP;hM=db(hK, hO, hM);} } }
function dc(hK, hL){ db(hK.parentNode, hL, hK);}
function dd(hK){ function hL(hM){ function hN(hO){ while(true){ if(hO!=null&&hO.$==0){ const hP=hO.$1;const hQ=hO.$0;if(hN(hQ))return true;else hO=hP;} else if(hO!=null&&hO.$==2){ const hR=hO.$0;if(hR.Dirty)return true;else hO=hR.Current;} else if(hO!=null&&hO.$==6){ const hS=hO.$0;return hS.Dirty||dB(hL, hS.Holes);} else return false;} } return hN(hM.Children);} fM(hK.El, hK.Attr);if(hL(hK))dh(hK);}
function de(hK){ while(true){ if(hK!=null&&hK.$==1)return c_(false, hK.$0);else if(hK!=null&&hK.$==2){ const hL=hK.$0;hK=hL.Current;} else if(hK==null)return null;else if(hK!=null&&hK.$==5)return null;else if(hK!=null&&hK.$==4){ const hM=hK.$0;return hM.Dirty?(hM.Text.nodeValue=hM.Value,hM.Dirty=false):null;} else if(hK!=null&&hK.$==6){ const hN=hK.$0;dw((hQ) => { c_(false, hQ);}, hN.Holes);dw((hQ) => { fM(hQ[0], hQ[1]);}, hN.Attrs);return df(hN);} else { const hO=hK.$1;const hP=hK.$0;de(hP);hK=hO;} } }
function df(hK){ const hL=hG(hK.Render);if(hL!=null&&hL.$==1){ hL.$0(hK.El);hD(hK, "Render", null);} }
function dg(hK, hL, hM){ fc(hK, hM, hL);return hL;}
function dh(hK){ const hL=hK.El;function hM(hQ, hR){ while(true){ if(hQ!=null&&hQ.$==1)return hQ.$0.El;else if(hQ!=null&&hQ.$==2){ const hS=hQ.$0;if(hS.Dirty){ hS.Dirty=false;return db(hL, hS.Current, hR);} else hQ=hS.Current;} else if(hQ==null)return hR;else if(hQ!=null&&hQ.$==4)return hQ.$0.Text;else if(hQ!=null&&hQ.$==5)return hQ.$0;else if(hQ!=null&&hQ.$==6){ const hT=hQ.$0;if(hT.Dirty)hT.Dirty=false;return dD((hW, hX) => hW==null||hW.constructor===Object?hM(hW, hX):hW, hT.Els, hR);} else { const hU=hQ.$1;const hV=hQ.$0;hQ=hV;hR=hM(hU, hR);} } } const hN=hK.El;hp((hQ) => { fd(hN, hQ);}, ho(hq(hK), hn(hK.El, hG(hK.Delimiters))));let hO=hK.Children;const hP=hG(hK.Delimiters);hM(hO, hP!=null&&hP.$==1?hP.$0[1]:null);}
function di(hK){ return{$:2, $0:hK};}
function dj(hK){ return{$:6, $0:hK};}
function dk(hK){ return{$:5, $0:hK};}
function dl(hK){ return{$:4, $0:hK};}
function dm(hK, hL){ return{$:0, $0:hK, $1:hL};}
let dn=hB((hK) => class hL extends m { static { dn=hK(this);} equals;hash;count;data;set_Item(hM, hN){ this.set(hM, hN);} TryGetValue(hM, hN){ const hO=this.data[this.hash(hM)];if(hO==null)return false;else { const hP=dx((hQ) => { const hR=k(hQ);return this.equals.apply(null, [hR[0], hM])?bV(hR[1]):null;}, hO);return hP!=null&&hP.$==1&&(hN.set(hP.$0),true);} } RemoveKey(hM){ return this.remove(hM);} set(hM, hN){ const hO=this.hash(hM);const hP=this.data[hO];if(hP==null){ this.count=this.count+1;this.data[hO]=new Array({K:hM, V:hN});} else { const hQ=dq((hR) => this.equals.apply(null, [(k(hR))[0], hM]), hP);if(hQ==null){ this.count=this.count+1;hP.push({K:hM, V:hN});} else hP[hQ.$0]={K:hM, V:hN};} } remove(hM){ const hN=this.hash(hM);const hO=this.data[hN];if(hO==null)return false;else { const hP=dz((hQ) =>!this.equals.apply(null, [(k(hQ))[0], hM]), hO);return g(hP)<hO.length&&(this.count=this.count-1,this.data[hN]=hP,true);} } GetEnumerator(){ return ey(dA(dN(this.data)));} ContainsKey(hM){ const hN=this.data[this.hash(hM)];return hN==null?false:dB((hO) => this.equals.apply(null, [(k(hO))[0], hM]), hN);} Item(hM){ return this.get(hM);} get Values(){ return new f$(this);} get Keys(){ return new gI(this);} get(hM){ const hN=this.data[this.hash(hM)];return hN==null?eB():dE((hO) => { const hP=k(hO);return this.equals.apply(null, [hP[0], hM])?bV(hP[1]):null;}, hN);} static New_5(){ return new this("New_5");} static New_6(hM, hN, hO){ return new this("New_6", hM, hN, hO);} constructor(hM, hN, hO, hP){ if(hM=="New_5"){ hM="New_6";hN=[];hO=V;hP=Y;} if(hM=="New_6"){ const hQ=hN;const hR=hO;const hS=hP;super();this.equals=hR;this.hash=hS;this.count=0;this.data=[];const hT=ev(hQ);try { while(hT.MoveNext()){ const hU=hT.Current;this.set(hU.K, hU.V);} } finally { if(typeof hT=="object"&&a(hT))hT.Dispose();} } } });
let do_1=hB((hK) => class hL extends m { static { do_1=hK(this);} equals;hash;data;count;SAdd(hM){ return this.add(hM);} Contains(hM){ const hN=this.data[this.hash(hM)];return hN==null?false:this.arrContains(hM, hN);} add(hM){ const hN=this.hash(hM);const hO=this.data[hN];return hO==null?(this.data[hN]=[hM],this.count=this.count+1,true):this.arrContains(hM, hO)?false:(hO.push(hM),this.count=this.count+1,true);} arrContains(hM, hN){ let hO=true;let hP=0;const hQ=hN.length;while(hO&&hP<hQ)if(this.equals.apply(null, [hN[hP], hM]))hO=false;else hP=hP+1;return!hO;} GetEnumerator(){ return ev(gJ(this.data));} ExceptWith(hM){ const hN=ev(hM);try { while(hN.MoveNext())this.Remove(hN.Current);} finally { if(typeof hN=="object"&&a(hN))hN.Dispose();} } get Count(){ return this.count;} IntersectWith(hM){ const hN=new do_1("New_4", hM, this.equals, this.hash);const hO=gJ(this.data);for(let hQ=0, hR=hO.length-1;hQ<=hR;hQ++){ const hP=hO[hQ];if(!hN.Contains(hP))this.Remove(hP);} } Remove(hM){ const hN=this.data[this.hash(hM)];return hN==null?false:this.arrRemove(hM, hN)&&(this.count=this.count-1,true);} CopyTo(hM, hN){ const hO=gJ(this.data);for(let hP=0, hQ=hO.length-1;hP<=hQ;hP++)i(hM, hP+hN, hO[hP]);} arrRemove(hM, hN){ let hO=true;let hP=0;const hQ=hN.length;while(hO&&hP<hQ)if(this.equals.apply(null, [hN[hP], hM])){ hN.splice(hP, 1);hO=false;} else hP=hP+1;return!hO;} static New_3(){ return new this("New_3");} static New_4(hM, hN, hO){ return new this("New_4", hM, hN, hO);} static New_2(hM){ return new this("New_2", hM);} constructor(hM, hN, hO, hP){ if(hM=="New_3"){ hM="New_4";hN=[];hO=V;hP=Y;} let hQ;if(hM=="New_2"){ hQ=hN;hM="New_4";hN=hQ;hO=V;hP=Y;} if(hM=="New_4"){ const hR=hN;const hS=hO;const hT=hP;super();this.equals=hS;this.hash=hT;this.data=[];this.count=0;const hU=ev(hR);try { while(hU.MoveNext())this.add(hU.Current);} finally { if(typeof hU=="object"&&a(hU))hU.Dispose();} } } });
function dp(hK, hL){ const hM=[];for(let hO=0, hP=hL.length-1;hO<=hP;hO++){ const hN=hK(hL[hO]);if(hN==null){ } else hM.push(hN.$0);} return hM;}
function dq(hK, hL){ let hM=null;let hN=0;while(hN<hL.length&&hM==null){ hK(hL[hN])?hM=bV(hN):void 0;hN=hN+1;} return hM;}
function dr(hK){ if(hK instanceof Array)return hK.slice();else if(hK instanceof b2)return ds(hK);else { const hL=[];const hM=ev(hK);try { while(hM.MoveNext())hL.push(hM.Current);return hL;} finally { if(typeof hM=="object"&&a(hM))hM.Dispose();} } }
function ds(hK){ const hL=[];let hM=hK;while(!(hM.$==0)){ hL.push(cc(hM));hM=cd(hM);} return hL;}
function dt(hK, hL, hM){ dy(hL, hM);const hN=new Array(hM.length);for(let hO=0, hP=hM.length-1;hO<=hP;hO++)hN[hO]=hK(hL[hO], hM[hO]);return hN;}
function du(hK, hL){ let hM=true;let hN=0;while(hM&&hN<g(hL))if(hK(hL[hN]))hN=hN+1;else hM=false;return hM;}
function dv(hK, hL){ if(hK<0)j("Negative size given.");else null;const hM=new Array(hK);for(let hN=0, hO=hK-1;hN<=hO;hN++)hM[hN]=hL(hN);return hM;}
function dw(hK, hL){ for(let hM=0, hN=hL.length-1;hM<=hN;hM++)hK(hL[hM]);}
function dx(hK, hL){ let hM=null;let hN=0;while(hN<hL.length&&hM==null){ const hO=hK(hL[hN]);if(hO!=null&&hO.$==1)hM=hO;hN=hN+1;} return hM;}
function dy(hK, hL){ if(hK.length!==hL.length)j("The arrays have different lengths.");}
function dz(hK, hL){ const hM=[];for(let hN=0, hO=hL.length-1;hN<=hO;hN++)if(hK(hL[hN]))hM.push(hL[hN]);return hM;}
function dA(hK){ return Array.prototype.concat.apply([], dr(hK));}
function dB(hK, hL){ let hM=false;let hN=0;while(!hM&&hN<g(hL))if(hK(hL[hN]))hM=true;else hN=hN+1;return hM;}
function dC(hK, hL){ const hM=new Array(hL.length);for(let hN=0, hO=hL.length-1;hN<=hO;hN++)hM[hN]=hK(hL[hN]);return hM;}
function dD(hK, hL, hM){ let hN=hM;const hO=hL.length;for(let hP=1, hQ=hO;hP<=hQ;hP++)hN=hK(hL[hO-hP], hN);return hN;}
function dE(hK, hL){ const hM=dx(hK, hL);return hM==null?j("KeyNotFoundException"):hM.$0;}
function dF(hK){ gF((hL) => hL[0], gE((hL, hM) =>[hM, hL], hK).sort(u0033));}
function dG(hK, hL){ const hM=new Array(hK);for(let hN=0, hO=hK-1;hN<=hO;hN++)hM[hN]=hL;return hM;}
let dH=hB((hK) => class hL extends m { static { dH=hK(this);} static init;id;vars;static initialized;static instances;static GetOrAddHoleFor(hM, hN, hO){ let hP;const hQ=dH.GetHolesFor(hM);const hR=(hP=null,[hQ.TryGetValue(hN, {get:() => hP, set:(hT) => { hP=hT;}}), hP]);if(hR[0])return hR[1];else { const hS=hO();hQ.set_Item(hN, hS);return hS;} } static GetHolesFor(hM){ let hN;const hO=(hN=null,[dH.initialized.TryGetValue(hM, {get:() => hN, set:(hQ) => { hN=hQ;}}), hN]);if(hO[0])return hO[1];else { const hP=new dn("New_5");dH.initialized.set_Item(hM, hP);return hP;} } static { dH.initialized=new dn("New_5");dH.instances=new dn("New_5");} });
function dI(hK){ return hK==null?null:bV(hK);}
let dJ=hB((hK) => { hE(o);return class hL extends o { static { dJ=hK(this);} name;fillWith;get Name(){ return this.name;} ForTextView(){ return bV(u0039(String, this.fillWith.View));} AddAttribute(hM, hN){(hM(hN))(fV(this.fillWith));} get AsChoiceView(){ return f5(u0039(String, this.fillWith.View));} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let dK=hB((hK) => { hE(o);return class hL extends o { static { dK=hK(this);} name;fillWith;get Name(){ return this.name;} ForTextView(){ return bV(u0039((hM) =>(new Date(hM)).toLocaleString(), this.fillWith.View));} AddAttribute(hM, hN){(hM(hN))(fW(this.fillWith));} get AsChoiceView(){ return f5(u0039((hM) =>(new Date(hM)).toLocaleString(), this.fillWith.View));} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let dL=hB((hK) => { hE(o);return class hL extends o { static { dL=hK(this);} name;fillWith;get Name(){ return this.name;} ForTextView(){ return bV(u0039(String, this.fillWith.View));} AddAttribute(hM, hN){(hM(hN))(fX(this.fillWith));} get AsChoiceView(){ return f5(u0039(String, this.fillWith.View));} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let dM=hB((hK) => { hE(o);return class hL extends o { static { dM=hK(this);} name;fillWith;get Name(){ return this.name;} get Value(){ return this.fillWith;} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
function dN(hK){ let hL=[];let hM;for(var hN in hK)hL.push(hK[hN]);return hL;}
let dO=hB((hK) => { hE(o);return class hL extends o { static { dO=hK(this);} name;fillWith;get Name(){ return this.name;} ForTextView(){ return bV(u0039((hM) => cO(",", hM), this.fillWith.View));} AddAttribute(hM, hN){(hM(hN))(fY(this.fillWith));} get AsChoiceView(){ return f5(u0039(String, this.fillWith.View));} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let dP=hB((hK) => class hL extends m { static { dP=hK(this);} });
function dQ(hK){ if(dT()==null){ dR("");dU("", null, globalThis.document.body, null);const hL=dV(globalThis.document.body, hK);const hM=globalThis.document.body;(((hO) => { bX.RunInPlace(true, hM, hO);})(hL));const hN=hL;dW(bV(hN));return hN;} else return dT().$0;}
function dR(hK){!dX()?(dY(true),dZ(globalThis.document.body, "")):void 0;d0().set_Item(hK, d1(""));}
function dS(hK, hL, hM){ let hN;const hO=(hN=null,[d1(hK).TryGetValue(hL==null?"":hL.$0, {get:() => hN, set:(hP) => { hN=hP;}}), hN]);return hO[0]?dV(hO[1].cloneNode(true), hM):(console.warn("Local template doesn't exist", hL),bX.Empty);}
function dT(){ return eV.RenderedFullDocTemplate;}
function dU(hK, hL, hM, hN){ const hO=new do_1("New_3");function hP(hW, hX){ while(true)switch(hW){ case 0:if(hX!==null){ const hY=hX.nextSibling;if(V(hX.nodeType, Node.TEXT_NODE))eW(hX);else if(V(hX.nodeType, Node.ELEMENT_NODE))hR(hX);hX=hY;} else return null;break;case 1:const hZ=e4(hX.nodeName, bV(3), null).toLowerCase();const h0=hZ.indexOf(".");const h1=h0===-1?[hK, hZ]:[e4(hZ, null, bV(h0-1)), e4(hZ, bV(h0+1), null)];const h2=h1[1];const h3=h1[0];if(h3!=""&&!d0().ContainsKey(h3))return eX(h2);else { if(h3==""&&hN!=null)hN.$0(h2);const h4=d0().Item(h3);if(!h4.ContainsKey(h2))return eX(h2);else { const h5=h4.Item(h2);const h6=h5.cloneNode(true);const h7=new do_1("New_3");const h8=new dn("New_5");const h9=hX.attributes;for(let ih=0, ii=h9.length-1;ih<=ii;ih++){ const h_=h9.item(ih).name.toLowerCase();const h$=h9.item(ih).nodeValue;let ia=h$==""?h_:h$.toLowerCase();h8.set_Item(h_, ia);if(!h7.SAdd(h_))console.warn("Hole mapped twice", h_);} for(let ij=0, ik=hX.childNodes.length-1;ij<=ik;ij++){ const ib=hX.childNodes[ij];if(V(ib.nodeType, Node.ELEMENT_NODE))if(!h7.SAdd(ib.nodeName.toLowerCase()))console.warn("Hole filled twice", h2);} const ic=hX.childNodes.length===1&&V(hX.firstChild.nodeType, Node.TEXT_NODE);if(ic){ const id=eY(h6, hX.firstChild.textContent, h2);const ie=((il) =>(im) => il.SAdd(im))(h7);let if_1=((il) =>(im) => { if(im!=null)il(im.$0);})((il) => { ie(il);});if_1(id);} eZ(h6, h7);if(!ic){ for(let il=0, im=hX.childNodes.length-1;il<=im;il++){ const ig=hX.childNodes[il];if(V(ig.nodeType, Node.ELEMENT_NODE))if(ig.hasAttributes())e0(h6, ig);else hQ(h6, ig);} } e1(h6, h8);e2(h6, hX.parentNode, hX);hX.parentNode.removeChild(hX);return;} } break;} } function hQ(hW, hX){ const hY=hX.nodeName.toLowerCase();const hZ=(h3, h4) => { if(hY=="title"&&hX.hasChildNodes()){ const h5=e5(hX.textContent);hX.removeChild(hX.firstChild);while(h5.hasChildNodes())hX.appendChild(h5.firstChild);} hR(hX);return e2(hX, h3, h4);};d2(hW, "[ws-attr-holes]", (h3) => { const h4=cP(h3.getAttribute("ws-attr-holes"), [" "], 1);for(let h8=0, h9=h4.length-1;h8<=h9;h8++){ const h5=f(h4, h8);let h6=new RegExp("\\${"+hY+"}", "ig");let h7=h3.getAttribute(h5).replace(h6, hX.textContent);h3.setAttribute(h5, h7);} });const h0=hW.querySelector("[ws-hole="+hY+"]");if(V(h0, null)){ const h1=hW.querySelector("[ws-replace="+hY+"]");if(V(h1, null)){ const h2=hW.querySelector("slot[name="+hY+"]");return hW.tagName.toLowerCase()=="template"?(hZ(h2.parentNode, h2),void h2.parentNode.removeChild(h2)):null;} else { hZ(h1.parentNode, h1);h1.parentNode.removeChild(h1);return;} } else { while(h0.hasChildNodes())h0.removeChild(h0.lastChild);h0.removeAttribute("ws-hole");return hZ(h0, null);} } function hR(hW){ if(!hW.hasAttribute("ws-preserve"))if(cN(hW.nodeName.toLowerCase(), "ws-"))hT(hW);else { e3(hW);hS(hW.firstChild);} } function hS(hW){ return hP(0, hW);} function hT(hW){ return hP(1, hW);} function hU(hW){ while(true){ const hX=hW.querySelector("[ws-template]");if(V(hX, null)){ const hY=hW.querySelector("[ws-children-template]");if(V(hY, null)){ const hZ=hW.querySelectorAll("template[id]");for(let h5=1, h6=hZ.length-1;h5<=h6;h5++){ const h0=hZ[h5];if(hO.Contains(h0)){ } else { dU(hK, bV(h0.getAttribute("id")), h0, null);hO.SAdd(h0);} } const h1=hW.querySelectorAll("template[name]");for(let h7=1, h8=h1.length-1;h7<=h8;h7++){ const h2=h1[h7];if(hO.Contains(h2)){ } else { dU(hK, bV(h2.getAttribute("name")), h2, null);hO.SAdd(h2);} } return null;} else { const h3=hY.getAttribute("ws-children-template");hY.removeAttribute("ws-children-template");dU(hK, bV(h3), hY, null);hW=hW;} } else { const h4=hX.getAttribute("ws-template");(d3(hK, bV(h4), hX))(null);hW=hW;} } } const hV=(hL==null?"":hL.$0).toLowerCase();d1(hK).set_Item(hV, hM);if(hM.hasChildNodes()){ hU(hM);hS(hM.firstChild);} }
function dV(hK, hL){ let hM;const hN=d4(hK, bm(hL, d5().Values));const hO=hN[1];const hP=hN[0];const hQ=hP.Els;return!V(hQ, null)&&hQ.length===1&&(f(hQ, 0)instanceof Node&&(V(f(hQ, 0).nodeType, Node.ELEMENT_NODE)&&(hM=f(hQ, 0),true)))?fe.TreeNode(hP, hO):bX.Mk(dj(hP), hO);}
function dW(hK){ eV.RenderedFullDocTemplate=hK;}
function dX(){ return eV.LocalTemplatesLoaded;}
function dY(hK){ eV.LocalTemplatesLoaded=hK;}
function dZ(hK, hL){ const hM=d1(hL);const hN=new dn("New_5");const hO=hK.querySelectorAll("[ws-template]");for(let h0=0, h1=hO.length-1;h0<=h1;h0++){ const hP=hO[h0];const hQ=hP.getAttribute("ws-template").toLowerCase();hP.removeAttribute("ws-template");hN.set_Item(hQ, d6(hP));} const hR=hK.querySelectorAll("[ws-children-template]");for(let h2=0, h3=hR.length-1;h2<=h3;h2++){ const hS=hR[h2];const hT=hS.getAttribute("ws-children-template").toLowerCase();hS.removeAttribute("ws-children-template");hN.set_Item(hT, d7(hS));} const hU=hK.querySelectorAll("template[id]");for(let h4=0, h5=hU.length-1;h4<=h5;h4++){ const hV=hU[h4];hN.set_Item(hV.getAttribute("id").toLowerCase(), d8(hV));} const hW=hK.querySelectorAll("template[name]");for(let h6=0, h7=hW.length-1;h6<=h7;h6++){ const hX=hW[h6];hN.set_Item(hX.getAttribute("name").toLowerCase(), d8(hX));} const hY=new do_1("New_3");function hZ(h8){ if(!hM.ContainsKey(h8)){ let h9;const h_=(h9=null,[hN.TryGetValue(h8, {get:() => h9, set:(h$) => { h9=h$;}}), h9]);if(h_[0]){ hY.SAdd(h8);hN.RemoveKey(h8);dU(hL, bV(h8), h_[1], bV(hZ));} else console.warn(hY.Contains(h8)?"Encountered loop when instantiating "+h8:"Local template does not exist: "+h8);} } while(hN.count>0)hZ(bw(hN.Keys));}
function d0(){ return eV.LoadedTemplates;}
function d1(hK){ let hL;const hM=(hL=null,[d0().TryGetValue(hK, {get:() => hL, set:(hO) => { hL=hO;}}), hL]);if(hM[0])return hM[1];else { const hN=new dn("New_5");d0().set_Item(hK, hN);return hN;} }
function d2(hK, hL, hM){ e$(hK, hL, (hN) => { if(hN.closest("[ws-preserve]")==null)hM(hN);});}
function d3(hK, hL, hM){ const hN=d6(hM);return(hO) => { dU(hK, hL, hN, hO);};}
function d4(hK, hL){ let hM;const hN=[];const hO=[];const hP=[];const hQ=[];const hR=new dn("New_5");const hS=ev(hL);try { while(hS.MoveNext()){ const hT=hS.Current;hR.set_Item(hT.Name, hT);} } finally { if(typeof hS=="object"&&a(hS))hS.Dispose();} const hU=fa(hK);const hV=(h2, h3) => { const h4=fx(h2, h3);hO.push(fy(h4));hP.push([h2, h4]);const h5=hG(h4.OnAfterRender);if(h5==null)return null;else { const h6=h5.$0;hQ.push(() => { h6(h2);});return;} };const hW=(h2) => { let h3;const h4=(h3=null,[hR.TryGetValue(h2, {get:() => h3, set:(h7) => { h3=h7;}}), h3]);if(h4[0]){ const h5=h4[1];if(h5 instanceof T)return bV(h5.Value);else if(h5 instanceof U)return bV(bX.TextNode(h5.Value));else { const h6=h5.ForTextView();return h6==null?null:bV(bX.TextView(h6.$0));} } else return null;};d2(hK, "[ws-hole]", (h2) => { const h3=h2.getAttribute("ws-hole");h2.removeAttribute("ws-hole");while(h2.hasChildNodes())h2.removeChild(h2.lastChild);const h4=hW(h3);if(h4!=null&&h4.$==1){ const h5=h4.$0;c3(h2, h5.docNode);hN.push(eU.New(fz(h2), h5.docNode, null, h2, eJ(), null));hO.push(h5.updates);} });d2(hK, "[ws-replace]", (h2) => { const h3=hW(h2.getAttribute("ws-replace"));if(h3!=null&&h3.$==1){ const h4=h3.$0;const h5=h2.parentNode;const h6=globalThis.document.createTextNode("");h5.replaceChild(h6, h2);const h7=c4(h6, h4.docNode);const h8=dq((h9) => h2===h9, hU);if(h8==null){ } else i(hU, h8.$0, h4.docNode);hN.push(eU.New(fz(h5), h4.docNode, bV([h7, h6]), h5, eJ(), null));hO.push(h4.updates);} });let hX=false;d2(hK, "slot", (h2) => { const h3=h2.getAttribute("name");const h4=h3==""||h3==null?"default":h3.toLowerCase();if(hX&&h4=="default"||!V(hK.parentElement, null)){ } else { while(h2.hasChildNodes())h2.removeChild(h2.lastChild);if(h4=="default")hX=true;const h5=hW(h4);if(h5!=null&&h5.$==1){ const h6=h5.$0;c3(h2, h6.docNode);hN.push(eU.New(fz(h2), h6.docNode, null, h2, eJ(), null));hO.push(h6.updates);} } });d2(hK, "[ws-attr]", (h2) => { let h3;const h4=h2.getAttribute("ws-attr");h2.removeAttribute("ws-attr");const h5=(h3=null,[hR.TryGetValue(h4, {get:() => h3, set:(h7) => { h3=h7;}}), h3]);if(h5[0]){ const h6=h5[1];if(h6 instanceof fO)hV(h2, h6.Value);else console.warn("Attribute hole filled with non-attribute data", h4);} });d2(hK, "[ws-on]", (h2) => { hV(h2, f1.Concat(dp((h3) => { let h4;const h5=cP(h3, [":"], 1);const h6=(h4=null,[hR.TryGetValue(f(h5, 1), {get:() => h4, set:(h8) => { h4=h8;}}), h4]);if(h6[0]){ const h7=h6[1];return h7 instanceof fP?bV(fQ(f(h5, 0), h7.Value)):h7 instanceof cL?bV(f1.Handler(f(h5, 0), h7.Value)):(console.warn("Event hole on"+f(h5, 0)+" filled with non-event data", f(h5, 1)),null);} else return null;}, cP(h2.getAttribute("ws-on"), [" "], 1))));h2.removeAttribute("ws-on");});d2(hK, "[ws-onafterrender]", (h2) => { let h3;const h4=h2.getAttribute("ws-onafterrender");const h5=(h3=null,[hR.TryGetValue(h4, {get:() => h3, set:(h7) => { h3=h7;}}), h3]);if(h5[0]){ const h6=h5[1];if(h6 instanceof f2){ h2.removeAttribute("ws-onafterrender");hV(h2, fR(h6.Value));} else if(h6 instanceof f3){ h2.removeAttribute("ws-onafterrender");hV(h2, fR(h6.Value));} else console.warn("onafterrender hole filled with non-onafterrender data", h4);} });d2(hK, "[ws-var]", (h2) => { let h3;const h4=h2.getAttribute("ws-var");h2.removeAttribute("ws-var");const h5=(h3=null,[hR.TryGetValue(h4, {get:() => h3, set:(h6) => { h3=h6;}}), h3]);if(h5[0])h5[1].AddAttribute((h6) =>(h7) => hV(h6, h7), h2);});const hY=() => { d_("[ws-dom]", (h2) => { let h3;let h4;let h5;const h6=(h3=null,[hR.TryGetValue(h2.getAttribute("ws-dom").toLowerCase(), {get:() => h3, set:(h_) => { h3=h_;}}), h3]);if(h6[0]){ const h7=h6[1];if(h7 instanceof dM){ const h8=h7.Value;h2.removeAttribute("ws-dom");h4=h2;const h9=new MutationObserver((h_, h$) => { dw((ia) => { ia.removedNodes.forEach(hH((ib) => ib[0]===h4&&ia.addedNodes.length!==1?(h8.SetFinal(null),h$.disconnect()):null), null);}, h_);});if(h2.parentElement!==null)h9.observe(h2.parentElement, (h5={},h5.childList=true,h5));h8.Set(bV(h2));ba((h_) => { if(h_!=null&&h_.$==1){ const h$=h_.$0;if(h4===h$){ } else { h4.replaceWith(h$);h4=h$;} } else { h4.remove();h9.disconnect();} }, h8.View);} } });};d2(hK, "[ws-attr-holes]", (h2) => { const h3=new RegExp(d9(), "g");const h4=cP(h2.getAttribute("ws-attr-holes"), [" "], 1);h2.removeAttribute("ws-attr-holes");for(let h5=0, h6=h4.length-1;h5<=h6;h5++)((() => { let h7;const h8=f(h4, h5);const h9=h2.getAttribute(h8);let h_=null;let h$=0;const ia=[];while(h_=h3.exec(h9),h_!==null){ const ib=e4(h9, bV(h$), bV(h3.lastIndex-f(h_, 0).length-1));h$=h3.lastIndex;ia.push([ib, f(h_, 1)]);} const ic=e4(h9, bV(h$), null);h3.lastIndex=0;const id=dD((ii, ij) =>(((ik) => { const il=ik[0];const im=ik[1];return(in_1) => { let io;const ip=in_1[0];const iq=in_1[1];const ir=(io=null,[hR.TryGetValue(im, {get:() => io, set:(it) => { io=it;}}), io]);const is=ir[0]?ir[1].AsChoiceView:f4("");return is.$==1?[il, b2.Cons(ip==""?is.$0:u0039((it) => it+ip, is.$0), iq)]:[il+is.$0+ip, iq];};})(ii))(ij), ia, [ic, b2.Empty]);if(id[1].$==1){ if(id[1].$1.$==1){ if(id[1].$1.$1.$==1){ if(id[1].$1.$1.$1.$==0){ const ie=id[0];h7=fS(h8, bh((ii, ij, ik) => ie+ii+ij+ik, id[1].$0, id[1].$1.$0, id[1].$1.$1.$0));} else { const if_1=id[0];h7=fS(h8, u0039((ii) => if_1+cO("", ii), bi(id[1])));} } else { const ig=id[0];h7=fS(h8, $((ii, ij) => ig+ii+ij, id[1].$0, id[1].$1.$0));} } else if(id[0]=="")h7=fS(h8, id[1].$0);else { const ih=id[0];h7=fS(h8, u0039((ii) => ih+ii, id[1].$0));} } else h7=f1.Create(h8, id[0]);return hV(h2, h7);})());});const hZ=hQ.length==0?bV(() => { hY();}):bV((h2) => { hY();dw((h3) => { h3(h2);}, hQ);});const h0=!V(hU, null)&&hU.length===1&&(f(hU, 0)instanceof Node&&(f(hU, 0)instanceof Element&&(hM=f(hU, 0),true)))?bV(hM):null;let h1=hI({Els:hU, Dirty:true, Holes:hN, Attrs:hP, Render:hZ?hZ.$0:void 0, El:h0?h0.$0:void 0}, ["Render", "El"]);return[h1, f6(bg(), bj, hO)];}
function d5(){ return eV.GlobalHoles;}
function d6(hK){ hK.removeAttribute("ws-template");const hL=hK.getAttribute("ws-replace");if(hL==null){ } else { hK.removeAttribute("ws-replace");const hM=hK.parentNode;if(V(hM, null)){ } else { const hN=globalThis.document.createElement(hK.tagName);hN.setAttribute("ws-replace", hL);hM.replaceChild(hN, hK);} } const hO=globalThis.document.createElement("div");hO.appendChild(hK);return hO;}
function d7(hK){ const hL=globalThis.document.createElement("div");while(hK.hasChildNodes())hL.appendChild(hK.firstChild);return hL;}
function d8(hK){ const hL=globalThis.document.createElement("div");const hM=hK.content;for(let hN=0, hO=hM.childNodes.length-1;hN<=hO;hN++)hL.appendChild(hM.childNodes[hN].cloneNode(true));return hL;}
function d9(){ return eV.TextHoleRE;}
function d_(hK, hL){ fb(hK, (hM) => { if(hM.closest("[ws-preserve]")==null)hL(hM);});}
let d$=hB((hK) => class hL { static { d$=hK(this);} Segments;QueryArgs;FormData;Method;Body;ToLink(){ return eD(this.Segments, this.QueryArgs);} static FromHash(hM, hN){ const hO=hM.indexOf("#");if(hO===-1)return d$.Empty;else { const hP=hM.substring(hO+1);return hN!=null&&hN.$0?hP==""||hP=="/"?d$.Empty:cN(hP, "/")?d$.FromUrl(hP.substring(1), bV(true)):d$.Segment_2(hP):d$.FromUrl(hM.substring(hO), bV(false));} } static Combine(hM){ let hN;let hO;let hP;let hQ;const hR=dr(hM);const hS=g(hR);if(hS===0)return d$.Empty;else if(hS===1)return f(hR, 0);else { hN=null;hO=null;const hT=[];hP=new fr("New", []);hQ=new fr("New", []);dw((hU) => { const hV=hU.Method;if(hV!=null&&hV.$==1)hN=hV;const hW=hU.Body;if(hW==null){ } else hO=hW;hP=fo((hX, hY, hZ) => hZ.Add_1(hX, hY), hP, hU.QueryArgs);hQ=fo((hX, hY, hZ) => hZ.Add_1(hX, hY), hQ, hU.FormData);b_((hX) => { hT.push(hX);}, hU.Segments);}, hR);return d$.New(b7(hT), hP, hQ, hN, hO);} } static Segment(hM, hN){ return d$.New(hM, d$.Empty.QueryArgs, d$.Empty.FormData, hN, d$.Empty.Body);} static get Empty(){ return d$.New(b2.Empty, new fr("New", []), new fr("New", []), null, bV(null));} static FromUrl(hM, hN){ const hO=hM.indexOf("?");const hP=hO===-1?[hM, new fr("New", [])]:[cQ(hM, 0, hO), d$.ParseQuery(hM.substring(hO+1))];return d$.New(b8(cP(hP[0], ["/"], hN!=null&&hN.$0?0:1)), hP[1], d$.Empty.FormData, d$.Empty.Method, d$.Empty.Body);} static Segment_2(hM){ return d$.New(b8([hM]), d$.Empty.QueryArgs, d$.Empty.FormData, d$.Empty.Method, d$.Empty.Body);} static ParseQuery(hM){ return fq(dr(dp((hN) => { const hO=cP(hN, ["="], 0);return!V(hO, null)&&hO.length===2?bV([f(hO, 0), f(hO, 1)]):((((hP) =>(hQ) => hP("wrong format for query argument: "+ft(hQ)))((hP) => { console.log(hP);}))(hN),null);}, cP(hM, ["&"], 0))));} static New(hM, hN, hO, hP, hQ){ return hF(d$, {Segments:hM, QueryArgs:hN, FormData:hO, Method:hP, Body:hQ});} });
function ea(hK){ let hL;const hM=hK.s;if(hM==null||(hM!=null&&hM.$==2?(hL=hM.$1,false):hM!=null&&hM.$==3?(hL=hM.$1,false):true))void 0;else { hK.s=null;for(let hO=0, hP=g(hL)-1;hO<=hP;hO++){ const hN=f(hL, hO);if(typeof hN=="object")(((hQ) => { ea(hQ);})(hN));else hN();} } }
let eb=hB((hK) => { hE(R);return class hL extends R { static { eb=hK(this);} isConst;current;snap;view;id;get View(){ return this.view;} Get(){ return this.current;} Set(hM){ if(this.isConst)(((hN) => hN("WebSharper.UI: invalid attempt to change value of a Var after calling SetFinal"))((hN) => { console.log(hN);}));else { ea(this.snap);this.current=hM;this.snap={s:eG(hM, [])};} } SetFinal(hM){ if(this.isConst)(((hN) => hN("WebSharper.UI: invalid attempt to change value of a Var after calling SetFinal"))((hN) => { console.log(hN);}));else { ea(this.snap);this.isConst=true;this.current=hM;this.snap={s:eH(hM)};} } UpdateMaybe(hM){ const hN=hM(this.Get());if(hN!=null&&hN.$==1)this.Set(hN.$0);} constructor(hM, hN, hO){ super();this.isConst=hM;this.current=hO;this.snap=hN;this.view=() => this.snap;this.id=eJ();} };});
function ec(hK){ return new eM(hK);}
function ed(hK){ return(hL) => { try {(hK())(hL);} catch(hM){ hL.k(eP(hM));} };}
function ee(hK, hL){ return hK()?ef(hL, () => ee(hK, hL)):ej();}
function ef(hK, hL){ return ek((hM) => { hK(eO((hN) => { if(hN.$==0){ const hO=hN.$0;ep().Fork(() => { try {(hL(hO))(hM);} catch(hP){ hM.k(eP(hP));} });} else ep().Fork(() => { hM.k(hN);});}, hM.ct));});}
function eg(hK){ return(hL) => { let hM;let hN;hM=void 0;hN=void 0;hM=setTimeout(() => { hN.Dispose();ep().Fork(() => { hL.k(eQ(null));});}, hK);hN=el(hL.ct, () => { clearTimeout(hM);ep().Fork(() => { em(hL);});});};}
function eh(){ return eS.Zero;}
function ei(hK, hL){ const hM=(en())[0];const hN=hL==null?hM:hL.$0;ep().Fork(() => { if(!hN.c)hK(eO((hO) => { if(hO.$==1)eo(hO.$0);}, hN));});}
function ej(hK){ return(hL) => { hL.k(eQ(hK));};}
function ek(hK){ return(hL) => { if(hL.ct.c)em(hL);else hK(hL);};}
function el(hK, hL){ if(hK===eq())return{Dispose(){ return null;}};else { const hM=hK.r.push(hL)-1;return{Dispose(){ return i(hK.r, hM, () => { });}};} }
function em(hK){ hK.k(eR(new fu("New", hK.ct)));}
function en(){ return eS.defCTS;}
function eo(hK){ console.log("WebSharper: Uncaught asynchronous exception", hK);}
function ep(){ return eS.scheduler;}
function eq(){ return eS.noneCT;}
function er(hK){ return(hL) => { const hM=[false];const hN=(hO) => { if(hM[0])j("A continuation provided by Async.FromContinuations was invoked multiple times");else { hM[0]=true;ep().Fork(hO);} };hK((hO) => { hN(() => { hL.k(eQ(hO));});}, (hO) => { hN(() => { hL.k(eP(hO));});}, (hO) => { hN(() => { hL.k(eR(hO));});});};}
function es(hK){ return() =>(hL) => { const hM=[];const hN=hK();b_((hO) => { hM.push(hN(hO));}, hL);return hM;};}
function et(){ return() =>(hK) => hK;}
function eu(hK){ return() =>(hL) => { const hM=hK();return b$(g(hL), (hN) => hM(f(hL, hN)));};}
function ev(hK){ return hK instanceof Array?ew(hK):V(typeof hK, "string")?ex(hK):hK.GetEnumerator();}
function ew(hK){ return new eC(0, null, (hL) => { const hM=hL.s;return hM<g(hK)&&(hL.c=f(hK, hM),hL.s=hM+1,true);}, void 0);}
function ex(hK){ return new eC(0, null, (hL) => { const hM=hL.s;return hM<hK.length&&(hL.c=hK[hM],hL.s=hM+1,true);}, void 0);}
function ey(hK){ return hK instanceof Array?ew(hK):V(typeof hK, "string")?ex(hK):"GetEnumerator0"in hK?hK.GetEnumerator0():hK.GetEnumerator();}
function ez(hK, hL){ const hM=(hO, hP) => { const hQ=hK==null?{}:new hK();const hR=f(hL, hO);const hS=hR[0];return hS!=null&&hS.$==1?hR[0].$0:(hQ.$=hO,bn((hT, hU) => { hQ["$"+String(hT)]=hU;}, hP),hQ);};const hN=dr(bo((hO) => { const hP=hO[0];const hQ=hO[1];const hR=hQ[2];return bq((hS) =>[hP, hS[0], hS[1], hR], hQ[1]);}, bp(hL)));return u0037((hO) => bo((hP) => { const hQ=hP[0];if(eA(hP[1], hO.Method)){ const hR=eN(b8(hP[2]), hO.Segments);if(hR==null)return[];else { const hS=hR.$0;const hT=b8(hP[3]);if(hT.$==0)return[[d$.New(hS, hO.QueryArgs, hO.FormData, hO.Method, hO.Body), hM(hQ, [])]];else { function hU(hV){ return(hW) =>(hX) => { if(hV.$==1){ const hY=hV.$1;return bo((hZ) =>((hU(hY))(hZ[0]))(b2.Cons(hZ[1], hX)), hV.$0.Parse(hW));} else return[[hW, hM(hQ, ds(ca(hX)))]];};} return((hU(hT))(d$.New(hS, hO.QueryArgs, hO.FormData, hO.Method, hO.Body)))(b2.Empty);} } } else return[];}, hN), (hO) => { const hP=br((hW) => { const hX=hW[0];return hX!=null&&hX.$==1&&V(hO, hX.$0);}, hL);const hQ=hP!=null&&hP.$==1?hP.$0:hO.$;const hR=f(hL, hQ);const hS=hR[2];const hT=f(hR[1], 0);const hU=[d$.Segment(b8(hT[1]), hT[0])];if(hS.length==0)return bV(hU);else { const hV=dt((hW, hX) => hX.Write(hW), dv(g((f(hL, hQ))[2]), (hW) => hO["$"+String(hW)]), hS);return du((hW) => hW!=null, hV)?bV(bm(hU, bo((hW) => hW.$0, hV))):null;} });}
function eA(hK, hL){ return hL!=null&&hL.$==1?hK!=null&&hK.$==1?V(hL.$0, hK.$0):true:!(hK!=null&&hK.$==1);}
function eB(){ throw new gR("New");}
let eC=hB((hK) => class hL extends m { static { eC=hK(this);} s;c;n;d;e;MoveNext(){ const hM=this.n(this);this.e=hM?1:2;return hM;} get Current(){ return this.e===1?this.c:this.e===0?j("Enumeration has not started. Call MoveNext."):j("Enumeration already finished.");} Dispose(){ if(this.d)this.d(this);} constructor(hM, hN, hO, hP){ super();this.s=hM;this.c=hN;this.n=hO;this.d=hP;this.e=0;} });
function eD(hK, hL){ const hM=hL.IsEmpty?"":"?"+eF(hL);return"/"+eE(hK)+hM;}
function eE(hK){ let hL;const hM=[];hL=true;b_((hN) => { if(!cT(hN)){ hL?hL=false:hM.push("/");hM.push(hN);} }, hK);return cU("", dr(hM));}
function eF(hK){ return cO("&", bq((hL) => hL[0]+"="+hL[1], fp(hK)));}
function eG(hK, hL){ return{$:2, $0:hK, $1:hL};}
function eH(hK){ return{$:0, $0:hK};}
function eI(hK, hL){ return{$:3, $0:hK, $1:hL};}
function eJ(){ eK(eL()+1);return eL();}
function eK(hK){ gB.counter=hK;}
function eL(){ return gB.counter;}
let eM=hB((hK) => class hL extends m { static { eM=hK(this);} init;SRemoveIf(hM, hN){ return dz((hO) =>!hM(hO), hN);} SSetAt(hM, hN, hO){ i(hO, hM, hN);return hO;} SAppend(hM, hN){ hN.push(hM);return hN;} SInit(){ return this.init;} constructor(hM){ super();this.init=hM;} });
function eN(hK, hL){ let hM;switch(hK.$==1?hL.$==1?V(hK.$0, hL.$0)?(hM=[hL.$0, hL.$1, hK.$0, hK.$1],1):2:2:0){ case 0:return bV(hL);case 1:return eN(hM[3], hM[1]);case 2:return null;} }
function eO(hK, hL){ return{k:hK, ct:hL};}
function eP(hK){ return{$:1, $0:hK};}
function eQ(hK){ return{$:0, $0:hK};}
function eR(hK){ return{$:2, $0:hK};}
let eS=hB((hK) => class hL { static { eS=hK(this);} static GetCT;static Zero;static defCTS;static scheduler;static noneCT;static { this.noneCT=eT(false, []);this.scheduler=new fs();this.defCTS=[new fv()];this.Zero=ej();this.GetCT=(hM) => { hM.k(eQ(hM.ct));};} });
function eT(hK, hL){ return{c:hK, r:hL};}
let eU=hB((hK) => class hL { static { eU=hK(this);} Attr;Children;Delimiters;El;ElKey;Render;Equals(hM){ return this.ElKey===hM.ElKey;} GetHashCode(){ return this.ElKey;} static New(hM, hN, hO, hP, hQ, hR){ const hS={Attr:hM, Children:hN, El:hP, ElKey:hQ};let hT=(hD(hS, "Delimiters", hO),hD(hS, "Render", hR),hS);return hF(eU, hT);} });
let eV=hB((hK) => class hL { static { eV=hK(this);} static RenderedFullDocTemplate;static TextHoleRE;static GlobalHoles;static LocalTemplatesLoaded;static LoadedTemplates;static { this.LoadedTemplates=new dn("New_5");this.LocalTemplatesLoaded=false;this.GlobalHoles=new dn("New_5");this.TextHoleRE="\\${([^}]+)}";this.RenderedFullDocTemplate=null;} });
function eW(hK){ let hL=null;let hM=0;const hN=hK.textContent;const hO=new RegExp(d9(), "g");while(hL=hO.exec(hN),hL!==null){ hK.parentNode.insertBefore(globalThis.document.createTextNode(e4(hN, bV(hM), bV(hO.lastIndex-f(hL, 0).length-1))), hK);hM=hO.lastIndex;const hP=globalThis.document.createElement("span");hP.setAttribute("ws-replace", f(hL, 1).toLowerCase());hK.parentNode.insertBefore(hP, hK);} hO.lastIndex=0;hK.textContent=e4(hN, bV(hM), null);}
function eX(hK){ console.warn("Instantiating non-loaded template", hK);}
function eY(hK, hL, hM){ const hN=hK.querySelector("[ws-replace]");return V(hN, null)?(console.warn("Filling non-existent text hole", hM),null):(hN.parentNode.replaceChild(globalThis.document.createTextNode(hL), hN),bV(hN.getAttribute("ws-replace")));}
function eZ(hK, hL){ const hM=(hN) => { d2(hK, "["+hN+"]", (hO) => { if(!hL.Contains(hO.getAttribute(hN)))hO.removeAttribute(hN);});};hM("ws-attr");hM("ws-onafterrender");hM("ws-var");d2(hK, "[ws-hole]", (hN) => { if(!hL.Contains(hN.getAttribute("ws-hole"))){ hN.removeAttribute("ws-hole");while(hN.hasChildNodes())hN.removeChild(hN.lastChild);} });d2(hK, "[ws-replace]", (hN) => { if(!hL.Contains(hN.getAttribute("ws-replace")))hN.parentNode.removeChild(hN);});d2(hK, "[ws-on]", (hN) => { hN.setAttribute("ws-on", cO(" ", dz((hO) => hL.Contains(f(cP(hO, [":"], 1), 1)), cP(hN.getAttribute("ws-on"), [" "], 1))));});d2(hK, "[ws-attr-holes]", (hN) => { const hO=cP(hN.getAttribute("ws-attr-holes"), [" "], 1);for(let hS=0, hT=hO.length-1;hS<=hT;hS++){ const hP=f(hO, hS);let hQ=new RegExp(d9(), "g");let hR=hN.getAttribute(hP).replace(hQ, (hU, hV) => hL.Contains(hV)?hU:"");hN.setAttribute(hP, hR);} });}
function e0(hK, hL){ e3(hL);const hM=hL.nodeName.toLowerCase();const hN=hK.querySelector("[ws-attr="+hM+"]");if(V(hN, null))console.warn("Filling non-existent attr hole", hM);else { hN.removeAttribute("ws-attr");for(let hP=0, hQ=hL.attributes.length-1;hP<=hQ;hP++){ const hO=hL.attributes.item(hP);if(hO.name=="class"&&hN.hasAttribute("class"))hN.setAttribute("class", hN.getAttribute("class")+" "+hO.nodeValue);else hN.setAttribute(hO.name, hO.nodeValue);} } }
function e1(hK, hL){ const hM=(hN) => { d2(hK, "["+hN+"]", (hO) => { let hP;const hQ=(hP=null,[hL.TryGetValue(hO.getAttribute(hN).toLowerCase(), {get:() => hP, set:(hR) => { hP=hR;}}), hP]);if(hQ[0])hO.setAttribute(hN, hQ[1]);});};hM("ws-hole");hM("ws-replace");hM("ws-attr");hM("ws-onafterrender");hM("ws-var");d2(hK, "[ws-on]", (hN) => { hN.setAttribute("ws-on", cO(" ", dC((hO) => { let hP;const hQ=cP(hO, [":"], 1);const hR=(hP=null,[hL.TryGetValue(f(hQ, 1), {get:() => hP, set:(hS) => { hP=hS;}}), hP]);return hR[0]?f(hQ, 0)+":"+hR[1]:hO;}, cP(hN.getAttribute("ws-on"), [" "], 1))));});d2(hK, "[ws-attr-holes]", (hN) => { const hO=cP(hN.getAttribute("ws-attr-holes"), [" "], 1);for(let hP=0, hQ=hO.length-1;hP<=hQ;hP++)((() => { const hR=f(hO, hP);return hN.setAttribute(hR, bx((hS, hT) => { const hU=k(hT);return hS.replace(new RegExp("\\${"+hU[0]+"}", "ig"), "${"+hU[1]+"}");}, hN.getAttribute(hR), hL));})());});}
function e2(hK, hL, hM){ while(true){ if(hK.hasChildNodes())hM=hL.insertBefore(hK.lastChild, hM);else return null;} }
function e3(hK){ const hL=hK.attributes;const hM=[];const hN=[];const hO=[];for(let hT=0, hU=hL.length-1;hT<=hU;hT++){ const hP=hL.item(hT);if(cN(hP.nodeName, "ws-on")&&hP.nodeName!="ws-onafterrender"&&hP.nodeName!="ws-on"){ hM.push(hP.nodeName);hN.push(e4(hP.nodeName, bV("ws-on".length), null)+":"+hP.nodeValue.toLowerCase());} else if(!cN(hP.nodeName, "ws-")&&(new RegExp(d9())).test(hP.nodeValue)){ let hQ=new RegExp(d9(), "g");let hR=hP.nodeValue.replace(hQ, (hV, hW) =>"${"+hW.toLowerCase()+"}");hP.nodeValue=hR;hO.push(hP.nodeName);} else void 0;} if(!(hN.length==0))hK.setAttribute("ws-on", cO(" ", hN));if(!(hO.length==0))hK.setAttribute("ws-attr-holes", cO(" ", hO));const hS=(hV) => { const hW=hK.getAttribute(hV);if(hW==null){ } else hK.setAttribute(hV, hW.toLowerCase());};hS("ws-hole");hS("ws-replace");hS("ws-attr");hS("ws-onafterrender");hS("ws-var");dw((hV) => { hK.removeAttribute(hV);}, hM);}
function e4(hK, hL, hM){ if(hL==null){ if(hM!=null&&hM.$==1){ const hN=hM.$0;return hN<0?"":hK.slice(0, hN+1);} else return"";} else if(hM==null)return hK.slice(hL.$0);else { const hO=hM.$0;return hO<0?"":hK.slice(hL.$0, hO+1);} }
function e5(hK){ const hL=globalThis.document.createElement("div");if(!e6().test(hK)){ hL.appendChild(globalThis.document.createTextNode(hK));return hL;} else { const hM=e_().exec(hK);const hN=V(hM, null)?"":f(hM, 1).toLowerCase();const hO=(e7())[hN];const hP=hO?hO:e8();hL.innerHTML=hP[1]+hK.replace(e9(), "<$1></$2>")+hP[2];function hQ(hR, hS){ while(true){ if(hS===0)return hR;else { const hT=hS;hR=hR.lastChild;hS=hT-1;} } } return hQ(hL, hP[0]);} }
function e6(){ return gK.rhtml;}
function e7(){ return gK.wrapMap;}
function e8(){ return gK.defaultWrap;}
function e9(){ return gK.rxhtmlTag;}
function e_(){ return gK.rtagName;}
function e$(hK, hL, hM){ const hN=hK.querySelectorAll(hL);for(let hO=0, hP=hN.length-1;hO<=hP;hO++)hM(hN[hO]);}
function fa(hK){ const hL=[];for(let hM=0, hN=hK.childNodes.length-1;hM<=hN;hM++)hL.push(hK.childNodes[hM]);return hL;}
function fb(hK, hL){ const hM=globalThis.document.querySelectorAll(hK);for(let hN=0, hO=hM.length-1;hN<=hO;hN++)hL(hM[hN]);}
function fc(hK, hL, hM){ let hN;if(hM.parentNode===hK){ const hO=hM.nextSibling;let hP=V(hO, null)?null:hO;hN=hL===hP;} else hN=false;if(!hN)hK.insertBefore(hM, hL);}
function fd(hK, hL){ if(hL.parentNode===hK)hK.removeChild(hL);}
let fe=hB((hK) => { hE(bX);return class hL extends bX { static { fe=hK(this);} docNode_1;updates_1;elt;rvUpdates;static TreeNode(hM, hN){ const hO=f_.Create(hN);const hP=dC((hS) => fy(hS[1]), hM.Attrs);let hQ=f6(bg(), bj, hP);let hR=bj(hQ, hO.v);return new hL(dj(hM), hR, f(hM.Els, 0), hO);} constructor(hM, hN, hO, hP){ super(hM, hN);this.docNode_1=hM;this.updates_1=hN;this.elt=hO;this.rvUpdates=hP;} };});
function ff(){ return gi();}
function fg(hK){ const hL=null;return ed(() => ef(fi(() => { }, gj(hK)), () => { gk(hK);return ej(null);}));}
function fh(hK, hL){ return fj(gM(hK.$0, hL.$0));}
function fi(hK, hL){ const hM=hL.Duration;if(hM===0)return eh();else { const hN=(hO) => { function hP(hQ){ return(hR) => { const hS=hR-hQ;hL.Compute(hS);hK();return hS<=hM?void requestAnimationFrame((hT) => {(hP(hQ))(hT);}):hO();};} requestAnimationFrame((hQ) => {(hP(hQ))(hQ);});};return er((hO, hP, hQ) => hN.apply(null, [hO, hP, hQ]));} }
function fj(hK){ return{$:0, $0:hK};}
function fk(hK){ return fj(gO(bq(gm, hK)));}
function fl(){ return fj(gP());}
function fm(){ return gq.BatchUpdatesEnabled;}
function fn(hK){ const hL=[0];function hM(){ const hN=null;return ed(() => ef(hK, () => { const hO=hL[0];return V(hO, 1)?(hL[0]=0,eh()):V(hO, 2)?(hL[0]=1,hM()):eh();}));} return() => { const hN=hL[0];if(V(hN, 0)){ hL[0]=1;ei(hM(), null);} else V(hN, 1)?hL[0]=2:void 0;};}
function fo(hK, hL, hM){ return bx((hN, hO) => hK(hO.Key, hO.Value, hN), hM, gr(true, hL.Tree));}
function fp(hK){ return bq((hL) =>[hL.Key, hL.Value], gr(false, hK.Tree));}
function fq(hK){ return new fr("New_1", gu(bq((hL) => gz.New(hL[0], hL[1]), hK)));}
let fr=hB((hK) => class hL extends m { static { fr=hK(this);} tree;Equals(hM){ return this.Count===hM.Count&&bA(V, this, hM);} Add_1(hM, hN){ return new fr("New_1", gs(gz.New(hM, hN), this.tree));} get IsEmpty(){ return this.tree==null;} GetEnumerator(){ return ev(bq((hM) =>({K:hM.Key, V:hM.Value}), gr(false, this.tree)));} get Count(){ const hM=this.tree;return hM==null?0:hM.Count;} get Tree(){ return this.tree;} GetHashCode(){ return Y(dr(this));} CompareTo0(hM){ return bN(u0033, this, hM);} static New(hM){ return new this("New", hM);} static New_1(hM){ return new this("New_1", hM);} constructor(hM, hN){ let hO;if(hM=="New"){ hO=hN;hM="New_1";hN=gQ(hO);} if(hM=="New_1"){ const hP=hN;super();this.tree=hP;} } });
let fs=hB((hK) => class hL extends m { static { fs=hK(this);} idle;robin;Fork(hM){ this.robin.push(hM);this.idle?(this.idle=false,setTimeout(() => { this.tick();}, 0)):void 0;} tick(){ const hM=Date.now();let hN=true;while(hN)if(this.robin.length===0){ this.idle=true;hN=false;} else {(this.robin.shift())();Date.now()-hM>40?(setTimeout(() => { this.tick();}, 0),hN=false):void 0;} } constructor(){ super();this.idle=true;this.robin=[];} });
function ft(hK){ return hK==null?"":hK;}
let fu=hB((hK) => { hE(Error);return class hL extends Error { static { fu=hK(this);} ct;static New(hM){ return new this("New", hM);} static New_1(hM, hN, hO){ return new this("New_1", hM, hN, hO);} constructor(hM, hN, hO, hP){ let hQ;if(hM=="New"){ hQ=hN;hM="New_1";hN="The operation was canceled.";hO=null;hP=hQ;} if(hM=="New_1"){ const hR=hN;const hS=hO;const hT=hP;super(hR);this.inner=hS;this.ct=hT;} } };});
let fv=hB((hK) => class hL extends m { static { fv=hK(this);} init;c;pending;r;constructor(){ super();this.c=false;this.pending=null;this.r=[];this.init=1;} });
function fw(hK, hL, hM, hN){ const hO={DynElem:hK, DynFlags:hL, DynNodes:hM};hD(hO, "OnAfterRender", hN);return hO;}
function fx(hK, hL){ const hM=[];const hN=[];function hO(hR){ while(true){ if(!(hR===null)){ if(hR!=null&&hR.$==1)return hM.push(hR.$0);else if(hR!=null&&hR.$==2){ const hS=hR.$1;const hT=hR.$0;hO(hT);hR=hS;} else return hR!=null&&hR.$==3?hR.$0(hK):hR!=null&&hR.$==4?hN.push(hR.$0):null;} else return null;} } hO(hL);const hP=hM.slice(0);let hQ=fw(hK, fA(hL), hP, hN.length===0?null:bV((hR) => { bB((hS) => { hS(hR);}, hN);}));return hQ;}
function fy(hK){ return f9((hL) => hL.NChanged, bg(), bj, hK.DynNodes);}
function fz(hK){ return fw(hK, 0, [], null);}
function fA(hK){ return hK!==null&&hK.hasOwnProperty("flags")?hK.flags:0;}
function fB(hK){ return f1.A3(hK);}
function fC(hK, hL){ return f1.A1(new gS(hK, hL));}
function fD(){ return gT.EmptyAttr;}
function fE(hK){ const hL=2;return(hK.DynFlags&hL)===hL;}
function fF(hK){ return fL(hK, (hL, hM) => hL.NGetExitAnim(hM));}
function fG(hK){ const hL=1;return(hK.DynFlags&hL)===hL;}
function fH(hK){ return fL(hK, (hL, hM) => hL.NGetEnterAnim(hM));}
function fI(hK){ const hL=4;return(hK.DynFlags&hL)===hL;}
function fJ(hK){ return fL(hK, (hL, hM) => hL.NGetChangeAnim(hM));}
function fK(hK, hL){ if(hK===null)return hL;else if(hL===null)return hK;else { const hM=f1.A2(hK, hL);fN(hM, fA(hK)|fA(hL));return hM;} }
function fL(hK, hL){ return fk(dC((hM) => hL(hM, hK.DynElem), hK.DynNodes));}
function fM(hK, hL){ dw((hM) => { hM.NSync(hK);}, hL.DynNodes);}
function fN(hK, hL){ hK.flags=hL;}
let fO=hB((hK) => { hE(o);return class hL extends o { static { fO=hK(this);} name;fillWith;get Value(){ return this.fillWith;} get Name(){ return this.name;} };});
let fP=hB((hK) => { hE(o);return class hL extends o { static { fP=hK(this);} name;fillWith;get Value(){ return this.fillWith;} get Name(){ return this.name;} };});
function fQ(hK, hL){ return fB((hM) => { hM.addEventListener(hK, (hN) =>(hL(hM))(hN), false);});}
function fR(hK){ return f1.A4(hK);}
function fS(hK, hL){ return fC(hL, (hM) =>(hN) => hM.setAttribute(hK, hN));}
function fT(hK){ return fZ(hf(), hK);}
function fU(hK){ return fZ(hg(), hK);}
function fV(hK){ return fZ(hh(), hK);}
function fW(hK){ return fZ(hi(), hK);}
function fX(hK){ return fZ(hj(), hK);}
function fY(hK){ return fZ(hk(), hK);}
function fZ(hK, hL){ const hM=hK(hL);return f1.Append(fB(hM[0]), f0(hM[1], hM[2]));}
function f0(hK, hL){ return fC(hL, hK);}
let f1=hB((hK) => class hL { static { f1=hK(this);} static Handler(hM, hN){ return f1.HandlerImpl(hM, hN);} static Concat(hM){ const hN=f8(hM);return f6(fD(), f1.Append, hN);} static Create(hM, hN){ return fB((hO) => { hO.setAttribute(hM, hN);});} static HandlerImpl(hM, hN){ return fB((hO) => { hO.addEventListener(hM, (hP) =>(hN(hO))(hP), false);});} static Append(hM, hN){ return fK(hM, hN);} static A4(hM){ return hF(hL, {$:4, $0:hM});} static A3(hM){ return hF(hL, {$:3, $0:hM});} static A1(hM){ return hF(hL, {$:1, $0:hM});} static A2(hM, hN){ return hF(hL, {$:2, $0:hM, $1:hN});} });
let f2=hB((hK) => { hE(o);return class hL extends o { static { f2=hK(this);} name;fillWith;get Value(){ return this.fillWith;} get Name(){ return this.name;} };});
let f3=hB((hK) => { hE(o);return class hL extends o { static { f3=hK(this);} name;fillWith;get Value(){ return this.fillWith;} get Name(){ return this.name;} };});
function f4(hK){ return{$:0, $0:hK};}
function f5(hK){ return{$:1, $0:hK};}
function f6(hK, hL, hM){ const hN=g(hM);function hO(hP){ return(hQ) => { let hR;switch(hQ<=0?0:hQ===1?hP>=0&&hP<hN?1:(hR=hQ,2):(hR=hQ,2)){ case 0:return hK;case 1:return f(hM, hP);case 2:const hS=hQ/2>>0;return hL((hO(hP))(hS), (hO(hP+hS))(hQ-hS));} };} return(hO(0))(hN);}
function f7(hK, hL){ for(let hM=0, hN=hL.length-1;hM<=hN;hM++)hL[hM]=hK(hL[hM]);return hL;}
function f8(hK){ if(hK instanceof Array)return hK;else if(hK instanceof b2)return ds(hK);else if(hK===null)return[];else { const hL=[];const hM=ev(hK);try { while(hM.MoveNext())hL.push(hM.Current);return hL;} finally { if(typeof hM=="object"&&a(hM))hM.Dispose();} } }
function f9(hK, hL, hM, hN){ const hO=g(hN);function hP(hQ){ return(hR) => { let hS;switch(hR<=0?0:hR===1?hQ>=0&&hQ<hO?1:(hS=hR,2):(hS=hR,2)){ case 0:return hL;case 1:return hK(f(hN, hQ));case 2:const hT=hR/2>>0;return hM((hP(hQ))(hT), (hP(hQ+hT))(hR-hT));} };} return(hP(0))(hO);}
let f_=hB((hK) => class hL { static { f_=hK(this);} c;s;v;static Create(hM){ let hN;hN=null;hN=f_.New(hM, null, () => { let hO;hO=hN.s;return hO===null?(hO=cz(hN.c()),hN.s=hO,cm(hO, () => { hN.s=null;}),hO):hO;});return hN;} static New(hM, hN, hO){ return hF(f_, {c:hM, s:hN, v:hO});} });
let f$=hB((hK) => class hL extends m { static { f$=hK(this);} d;GetEnumerator(){ return ev(bq((hM) => hM.V, this.d));} constructor(hM){ super();this.d=hM;} });
function ga(hK, hL){ return{PreviousNodes:hK, Top:hL};}
function gb(){ return gd(new do_1("New_3"));}
function gc(hK){ const hL=[];function hM(hP, hQ){ while(true)switch(hP){ case 0:if(hQ!=null&&hQ.$==0){ const hR=hQ.$1;const hS=hQ.$0;hM(0, hS);hQ=hR;} else if(hQ!=null&&hQ.$==1){ const hT=hQ.$0;hQ=hT;hP=1;} else if(hQ!=null&&hQ.$==2){ const hU=hQ.$0;hQ=hU.Current;} else if(hQ!=null&&hQ.$==6){ const hV=hQ.$0.Holes;return(((hW) =>(hX) => { dw(hW, hX);})(hO))(hV);} else return null;break;case 1:hL.push(hQ);hQ=hQ.Children;hP=0;break;} } function hN(hP){ return hM(0, hP);} function hO(hP){ return hM(1, hP);} hN(hK);return gd(new do_1("New_2", hL));}
function gd(hK){ return{$:0, $0:hK};}
function ge(hK, hL){ return gd(gV(hK, hL.$0));}
function gf(hK, hL){ return gd(gW(hK.$0, hL.$0));}
function gg(hK){ return gX(hK.$0);}
function gh(hK, hL){ return gd(gY(hK.$0, hL.$0));}
function gi(){ return gL.UseAnimations;}
function gj(hK){ return gl(dp((hL) => hL.$==1?bV(hL.$0):null, gN(hK.$0)));}
function gk(hK){ dw((hL) => { if(hL.$==0)hL.$0();}, gN(hK.$0));}
function gl(hK){ const hL=f8(hK);const hM=g(hL);if(hM===0)return gn();else if(hM===1)return f(hL, 0);else { const hN=bG(bq((hP) => hP.Duration, hL));const hO=dC((hP) => gp(hN, hP), hL);return go(hN, (hP) => { dw((hQ) => { hQ.Compute(hP);}, hO);});} }
function gm(hK){ return hK.$0;}
function gn(hK){ return go(0, () => hK);}
function go(hK, hL){ return{Compute:hL, Duration:hK};}
function gp(hK, hL){ const hM=hL.Compute;const hN=hL.Duration;const hO=hv(() => hL.Compute(hL.Duration));return{Compute:(hP) => hP>=hN?hO.f():hM(hP), Duration:hK};}
let gq=hB((hK) => class hL { static { gq=hK(this);} static BatchUpdatesEnabled;static { this.BatchUpdatesEnabled=true;} });
function gr(hK, hL){ function hM(hN, hO){ let hP;while(true){ if(hN==null)return hO.$==1?bV([hO.$0[0], [hO.$0[1], hO.$1]]):null;else if(hK){ hP=hN;hN=hP.Right;hO=b2.Cons([hP.Node, hP.Left], hO);} else { hP=hN;hN=hP.Left;hO=b2.Cons([hP.Node, hP.Right], hO);} } } return bE((hN) => hM(hN[0], hN[1]), [hL, b2.Empty]);}
function gs(hK, hL){ return gt((hM, hN) => hN, hK, hL);}
function gt(hK, hL, hM){ const hN=gw(hL, hM);const hO=hN[0];return hO==null?gx(hN[1], gy(hL, null, null)):gx(hN[1], gy(hK(hO.Node, hL), hO.Left, hO.Right));}
function gu(hK){ const hL=dr(bH(hK));dF(hL);return gv(hL, 0, hL.length-1);}
function gv(hK, hL, hM){ if(hM-hL+1<=0)return null;else { const hN=(hL+hM)/2>>0;return gy(f(hK, hN), gv(hK, hL, hN-1), gv(hK, hN+1, hM));} }
function gw(hK, hL){ let hM=[];let hN=hL;let hO=true;while(hO)if(hN==null)hO=false;else { const hP=u0033(hK, hN.Node);if(hP===0)hO=false;else hP===1?(hM.unshift([true, hN.Node, hN.Left]),hN=hN.Right):(hM.unshift([false, hN.Node, hN.Right]),hN=hN.Left);} return[hN, hM];}
function gx(hK, hL){ const hM=(hV) => hV==null?0:hV.Height;let hN=hL;for(let hV=0, hW=g(hK)-1;hV<=hW;hV++){ const hO=f(hK, hV);if(hO[0]){ const hP=hO[1];const hQ=hO[2];if(hM(hN)>hM(hQ)+1){ if(hM(hN.Left)===hM(hN.Right)+1){ const hR=hN.Left;hN=gy(hR.Node, gy(hP, hQ, hR.Left), gy(hN.Node, hR.Right, hN.Right));} else hN=gy(hN.Node, gy(hP, hQ, hN.Left), hN.Right);} else hN=gy(hP, hQ, hN);} else { const hS=hO[1];const hT=hO[2];if(hM(hN)>hM(hT)+1){ if(hM(hN.Right)===hM(hN.Left)+1){ const hU=hN.Right;hN=gy(hU.Node, gy(hN.Node, hN.Left, hU.Left), gy(hS, hU.Right, hT));} else hN=gy(hN.Node, hN.Left, gy(hS, hN.Right, hT));} else hN=gy(hS, hN, hT);} } return hN;}
function gy(hK, hL, hM){ const hN=hL==null?0:hL.Height;const hO=hM==null?0:hM.Height;let hP=u0033(hN, hO)===1?hN:hO;let hQ=1+hP;return gA(hK, hL, hM, hQ, 1+(hL==null?0:hL.Count)+(hM==null?0:hM.Count));}
let gz=hB((hK) => class hL { static { gz=hK(this);} Key;Value;Equals(hM){ return V(this.Key, hM.Key);} GetHashCode(){ return Y(this.Key);} CompareTo0(hM){ return u0033(this.Key, hM.Key);} static New(hM, hN){ return hF(gz, {Key:hM, Value:hN});} });
function gA(hK, hL, hM, hN, hO){ return{Node:hK, Left:hL, Right:hM, Height:hN, Count:hO};}
let gB=hB((hK) => class hL { static { gB=hK(this);} static counter;static { this.counter=0;} });
function gC(hK){ hK.splice(0, g(hK));}
function gD(){ return j("The input sequence has an insufficient number of elements.");}
function gE(hK, hL){ for(let hM=0, hN=hL.length-1;hM<=hN;hM++)hL[hM]=hK(hM, hL[hM]);return hL;}
function gF(hK, hL){ for(let hM=0, hN=hL.length-1;hM<=hN;hM++)hL[hM]=hK(hL[hM]);}
function gG(hK, hL){ let hM=true;let hN=0;while(hM&&hN<g(hL))if(V(hL[hN], hK))hM=false;else hN=hN+1;return!hM;}
function gH(){ return j("The input must be non-negative.");}
let gI=hB((hK) => class hL extends m { static { gI=hK(this);} d;GetEnumerator(){ return ev(bq((hM) => hM.K, this.d));} constructor(hM){ super();this.d=hM;} });
function gJ(hK){ let hL=[];let hM;for(var hN in hK)hL.push.apply(hL, hK[hN]);return hL;}
let gK=hB((hK) => class hL { static { gK=hK(this);} static defaultWrap;static wrapMap;static rhtml;static rtagName;static rxhtmlTag;static { this.rxhtmlTag=new RegExp("<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>", "gi");this.rtagName=new RegExp("<([\\w:]+)");this.rhtml=new RegExp("<|&#?\\w+;");const hM=[1, "<table>", "</table>"];let hN=Object.fromEntries([["option", [1, "<select multiple='multiple'>", "</select>"]], ["legend", [1, "<fieldset>", "</fieldset>"]], ["area", [1, "<map>", "</map>"]], ["param", [1, "<object>", "</object>"]], ["thead", hM], ["tbody", hM], ["tfoot", hM], ["tr", [2, "<table><tbody>", "</tbody></table>"]], ["col", [2, "<table><colgroup>", "</colgoup></table>"]], ["td", [3, "<table><tbody><tr>", "</tr></tbody></table>"]]]);this.wrapMap=hN;this.defaultWrap=[0, "", ""];} });
let gL=hB((hK) => class hL { static { gL=hK(this);} static UseAnimations;static CubicInOut;static { this.CubicInOut=gU.Custom((hM) => { const hN=hM*hM;return 3*hN-2*(hN*hM);});this.UseAnimations=true;} });
function gM(hK, hL){ return hK.$==0?hL:hL.$==0?hK:{$:2, $0:hK, $1:hL};}
function gN(hK){ const hL=[];function hM(hN){ while(true){ if(hN.$==1)return hL.push(hN.$0);else if(hN.$==2){ const hO=hN.$1;const hP=hN.$0;hM(hP);hN=hO;} else return hN.$==3?dw((hQ) => { hL.push(hQ);}, hN.$0):null;} } hM(hK);return hL.slice(0);}
function gO(hK){ const hL=f8(hK);return f6(gP(), gM, hL);}
function gP(){ return hy.Empty;}
function gQ(hK){ const hL=dr(bq((hM) => gz.New(hM[0], hM[1]), bt((hM) => hM[0], bD(hK))));dF(hL);return gv(hL, 0, hL.length-1);}
let gR=hB((hK) => { hE(Error);return class hL extends Error { static { gR=hK(this);} static New(){ return new this("New");} static New_1(hM){ return new this("New_1", hM);} constructor(hM, hN){ if(hM=="New"){ hM="New_1";hN="The given key was not present in the dictionary.";} if(hM=="New_1"){ const hO=hN;super(hO);} } };});
let gS=hB((hK) => class hL extends m { static { gS=hK(this);} push;value;dirty;updates;get NChanged(){ return this.updates;} NGetExitAnim(hM){ return fl();} NGetEnterAnim(hM){ return fl();} NGetChangeAnim(hM){ return fl();} NSync(hM){ if(this.dirty){(this.push(hM))(this.value);this.dirty=false;} } constructor(hM, hN){ super();this.push=hN;this.value=void 0;this.dirty=false;this.updates=u0039((hO) => { this.value=hO;this.dirty=true;}, hM);} });
let gT=hB((hK) => class hL { static { gT=hK(this);} static FloatApplyChecked;static FloatGetChecked;static FloatSetChecked;static FloatApplyUnchecked;static FloatGetUnchecked;static FloatSetUnchecked;static IntApplyChecked;static IntGetChecked;static IntSetChecked;static IntApplyUnchecked;static IntGetUnchecked;static IntSetUnchecked;static FileApplyUnchecked;static FileGetUnchecked;static FileSetUnchecked;static DateTimeApplyUnchecked;static DateTimeGetUnchecked;static DateTimeSetUnchecked;static StringListApply;static StringListGet;static StringListSet;static StringApply;static StringGet;static StringSet;static BoolCheckedApply;static EmptyAttr;static { this.EmptyAttr=null;this.BoolCheckedApply=(h2) =>[(h3) => { h3.addEventListener("change", () => h2.Get()!=h3.checked?h2.Set(h3.checked):null);}, (h3) =>(h4) => h4!=null&&h4.$==1?void(h3.checked=h4.$0):null, u0039(bV, h2.View)];this.StringSet=(h2) =>(h3) => { h2.value=h3;};this.StringGet=(h2) => bV(h2.value);const hM=g1();const hN=g0();this.StringApply=(h2) => gZ(hM, hN, h2);this.StringListSet=(h2) =>(h3) => { const h4=h2.options;for(let h5=0, h6=h4.length-1;h5<=h6;h5++)((() => { const h7=h4.item(h5);h7.selected=gG(h7.value, h3);})());};this.StringListGet=(h2) => { const h3=h2.selectedOptions;return bV(dr(bF(() => bo((h4) =>[h3.item(h4).value], l(0, h3.length-1)))));};const hO=g3();const hP=g2();this.StringListApply=(h2) => gZ(hO, hP, h2);this.DateTimeSetUnchecked=(h2) =>(h3) => { h2.value=(new Date(h3)).toLocaleString();};this.DateTimeGetUnchecked=(h2) => { let h3;let h4;const h5=h2.value;if(hl(h5))return bV(-8640000000000000);else { h3=0;const h6=ht(h5);let h7=h6!=null&&h6.$==1&&(h3=h6.$0,true);h4=[h7, h3];return h4[0]?bV(h4[1]):null;} };const hQ=g5();const hR=g4();this.DateTimeApplyUnchecked=(h2) => gZ(hQ, hR, h2);this.FileSetUnchecked=() =>() => null;this.FileGetUnchecked=(h2) => { const h3=h2.files;return bV(dr(bF(() => bq((h4) => h3.item(h4), l(0, h3.length-1)))));};const hS=g8();const hT=g7();this.FileApplyUnchecked=(h2) => g6(hS, hT, h2);this.IntSetUnchecked=(h2) =>(h3) => { h2.value=String(h3);};this.IntGetUnchecked=(h2) => { const h3=h2.value;if(hl(h3))return bV(0);else { const h4=+h3;return h4!==h4>>0?null:bV(h4);} };const hU=g_();const hV=g9();this.IntApplyUnchecked=(h2) => gZ(hU, hV, h2);this.IntSetChecked=(h2) =>(h3) => { const h4=h3.Input;return h2.value!=h4?void(h2.value=h4):null;};this.IntGetChecked=(h2) => { let h3;let h4;const h5=h2.value;if(hl(h5))h3=(h2.checkValidity?h2.checkValidity():true)?hm.Blank(h5):hm.Invalid(h5);else { const h6=(h4=0,[cH(h5, {get:() => h4, set:(h7) => { h4=h7;}}), h4]);h3=h6[0]?hm.Valid(h6[1], h5):hm.Invalid(h5);} return bV(h3);};const hW=ha();const hX=g$();this.IntApplyChecked=(h2) => gZ(hW, hX, h2);this.FloatSetUnchecked=(h2) =>(h3) => { h2.value=String(h3);};this.FloatGetUnchecked=(h2) => { const h3=h2.value;if(hl(h3))return bV(0);else { const h4=+h3;return isNaN(h4)?null:bV(h4);} };const hY=hc();const hZ=hb();this.FloatApplyUnchecked=(h2) => gZ(hY, hZ, h2);this.FloatSetChecked=(h2) =>(h3) => { const h4=h3.Input;return h2.value!=h4?void(h2.value=h4):null;};this.FloatGetChecked=(h2) => { let h3;const h4=h2.value;if(hl(h4))h3=(h2.checkValidity?h2.checkValidity():true)?hm.Blank(h4):hm.Invalid(h4);else { const h5=+h4;h3=isNaN(h5)?hm.Invalid(h4):hm.Valid(h5, h4);} return bV(h3);};const h0=he();const h1=hd();this.FloatApplyChecked=(h2) => gZ(h0, h1, h2);} });
let gU=hB((hK) => class hL extends m { static { gU=hK(this);} transformTime;static Custom(hM){ return new hL(hM);} constructor(hM){ super();this.transformTime=hM;} });
function gV(hK, hL){ return new do_1("New_2", dz(hK, gX(hL)));}
function gW(hK, hL){ const hM=new do_1("New_2", gX(hL));hM.ExceptWith(gX(hK));return hM;}
function gX(hK){ const hL=dG(hK.Count, void 0);hK.CopyTo(hL, 0);return hL;}
function gY(hK, hL){ const hM=new do_1("New_2", gX(hK));hM.IntersectWith(gX(hL));return hM;}
function gZ(hK, hL, hM){ let hN;hN=null;return[(hO) => { const hP=() => { hM.UpdateMaybe((hQ) => { let hR;hN=hK(hO);return hN!=null&&hN.$==1&&(!V(hN.$0, hQ)&&(hR=[hN, hN.$0],true))?hR[0]:null;});};hO.addEventListener("change", hP);hO.addEventListener("input", hP);hO.addEventListener("keypress", hP);}, (hO) => { const hP=hL(hO);return(hQ) => hQ==null?null:hP(hQ.$0);}, u0039((hO) => { let hP;return hN!=null&&hN.$==1&&(V(hN.$0, hO)&&(hP=hN.$0,true))?null:bV(hO);}, hM.View)];}
function g0(){ return gT.StringSet;}
function g1(){ return gT.StringGet;}
function g2(){ return gT.StringListSet;}
function g3(){ return gT.StringListGet;}
function g4(){ return gT.DateTimeSetUnchecked;}
function g5(){ return gT.DateTimeGetUnchecked;}
function g6(hK, hL, hM){ let hN;hN=null;return[(hO) => { hO.addEventListener("change", () => { hM.UpdateMaybe((hP) => { let hQ;hN=hK(hO);return hN!=null&&hN.$==1&&(hN.$0!==hP&&(hQ=[hN, hN.$0],true))?hQ[0]:null;});});}, (hO) => { const hP=hL(hO);return(hQ) => hQ==null?null:hP(hQ.$0);}, u0039((hO) => { let hP;return hN!=null&&hN.$==1&&(V(hN.$0, hO)&&(hP=hN.$0,true))?null:bV(hO);}, hM.View)];}
function g7(){ return gT.FileSetUnchecked;}
function g8(){ return gT.FileGetUnchecked;}
function g9(){ return gT.IntSetUnchecked;}
function g_(){ return gT.IntGetUnchecked;}
function g$(){ return gT.IntSetChecked;}
function ha(){ return gT.IntGetChecked;}
function hb(){ return gT.FloatSetUnchecked;}
function hc(){ return gT.FloatGetUnchecked;}
function hd(){ return gT.FloatSetChecked;}
function he(){ return gT.FloatGetChecked;}
function hf(){ return gT.FloatApplyUnchecked;}
function hg(){ return gT.StringApply;}
function hh(){ return gT.BoolCheckedApply;}
function hi(){ return gT.DateTimeApplyUnchecked;}
function hj(){ return gT.FileApplyUnchecked;}
function hk(){ return gT.StringListApply;}
function hl(hK){ return cW(hs, hK);}
let hm=hB((hK) => class hL { static { hm=hK(this);} get Input(){ return this.$==1?this.$0:this.$==2?this.$0:this.$1;} static Blank(hM){ return hF(hL, {$:2, $0:hM});} static Invalid(hM){ return hF(hL, {$:1, $0:hM});} static Valid(hM, hN){ return hF(hL, {$:0, $0:hM, $1:hN});} });
function hn(hK, hL){ let hM;if(hL!=null&&hL.$==1){ const hN=[];hM=hL.$0[0].nextSibling;while(hM!==hL.$0[1]){ hN.push(hM);hM=hM.nextSibling;} return hr(hN);} else { let hO=hK.childNodes.length;const hP=hK.childNodes;let hQ=dv(hO, (hR) => hP[hR]);return hr(hQ);} }
function ho(hK, hL){ const hM=hK.$0;return hr(dz((hN) => du((hO) =>!(hN===hO), hM), hL.$0));}
function hp(hK, hL){ dw(hK, hL.$0);}
function hq(hK){ const hL=[];function hM(hN){ while(true){ if(hN!=null&&hN.$==2){ const hO=hN.$0;hN=hO.Current;} else if(hN!=null&&hN.$==1)return hL.push(hN.$0.El);else if(hN==null)return null;else if(hN!=null&&hN.$==5)return hL.push(hN.$0);else if(hN!=null&&hN.$==4)return hL.push(hN.$0.Text);else if(hN!=null&&hN.$==6){ const hP=hN.$0.Els;return(((hS) =>(hT) => { dw(hS, hT);})((hS) => { if(hS==null||hS.constructor===Object)hM(hS);else hL.push(hS);}))(hP);} else { const hQ=hN.$1;const hR=hN.$0;hM(hR);hN=hQ;} } } hM(hK.Children);return hr(f8(hL));}
function hr(hK){ return{$:0, $0:hK};}
function hs(hK){ return hK.match(new RegExp("\\s"))!==null;}
function ht(hK){ const hL=Date.parse(hK);return isNaN(hL)?null:bV(hL);}
function hu(hK, hL, hM, hN){ const hO=+hK;const hP=hO===hO-hO%1&&hO>=hL&&hO<=hM;if(hP)hN.set(hO);return hP;}
function hv(hK){ return hz(false, hK, hw);}
function hw(){ const hK=this.v();this.c=true;this.v=hK;this.f=hx;return hK;}
function hx(){ return this.v;}
let hy=hB((hK) => class hL { static { hy=hK(this);} static Empty;static { this.Empty={$:0};} });
function hz(hK, hL, hM){ return{c:hK, v:hL, f:hM};}
hJ(() => { b();});
hA();

